<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# server

```go
import "github.com/uponusolutions/go-smtp/server"
```

<details><summary>Example</summary>
<p>



```go
// Set up authentication information.
auth := sasl.NewPlainClient("", "user@example.com", "password")

// Connect to the server, authenticate, set the sender and recipient,
// and send the email all in one step.
to := []string{"recipient@example.net"}
msg := strings.NewReader("To: recipient@example.net\r\n" +
	"Subject: discount Gophers!\r\n" +
	"\r\n" +
	"This is the email body.\r\n")

c := client.New(
	client.WithServerAddresses("mail.example.com:25"),
	client.WithSASLClient(auth),
)

_, _, err := c.SendMail("sender@example.org", to, msg)
if err != nil {
	log.Fatal(err)
}
```

</p>
</details>

<details><summary>Example (Plain Auth)</summary>
<p>



```go
// hostname is used by PlainAuth to validate the TLS certificate.
hostname := "mail.example.com"
auth := sasl.NewPlainClient("", "user@example.com", "password")

c := client.New(
	client.WithServerAddresses(hostname+":25"),
	client.WithSASLClient(auth),
)

_, _, err := c.SendMail(from, recipients, msg)
if err != nil {
	log.Fatal(err)
}
```

</p>
</details>

## Index

- [Variables](<#variables>)
- [type Backend](<#Backend>)
- [type BackendFunc](<#BackendFunc>)
  - [func \(f BackendFunc\) NewSession\(ctx context.Context, c \*Conn\) \(context.Context, Session, error\)](<#BackendFunc.NewSession>)
- [type Conn](<#Conn>)
  - [func \(c \*Conn\) Close\(err error\)](<#Conn.Close>)
  - [func \(c \*Conn\) Conn\(\) net.Conn](<#Conn.Conn>)
  - [func \(c \*Conn\) Hostname\(\) string](<#Conn.Hostname>)
  - [func \(c \*Conn\) IsTLS\(\) bool](<#Conn.IsTLS>)
  - [func \(c \*Conn\) Mechanisms\(\) \[\]string](<#Conn.Mechanisms>)
  - [func \(c \*Conn\) Server\(\) \*Server](<#Conn.Server>)
  - [func \(c \*Conn\) TLSConnectionState\(\) \(tls.ConnectionState, bool\)](<#Conn.TLSConnectionState>)
- [type Option](<#Option>)
  - [func WithAddr\(addr string\) Option](<#WithAddr>)
  - [func WithBackend\(backend Backend\) Option](<#WithBackend>)
  - [func WithEnableBINARYMIME\(enableBINARYMIME bool\) Option](<#WithEnableBINARYMIME>)
  - [func WithEnableCHUNKING\(enableCHUNKING bool\) Option](<#WithEnableCHUNKING>)
  - [func WithEnableDSN\(enableDSN bool\) Option](<#WithEnableDSN>)
  - [func WithEnableREQUIRETLS\(enableREQUIRETLS bool\) Option](<#WithEnableREQUIRETLS>)
  - [func WithEnableSMTPUTF8\(enableSMTPUTF8 bool\) Option](<#WithEnableSMTPUTF8>)
  - [func WithEnableXOORG\(enableXOORG bool\) Option](<#WithEnableXOORG>)
  - [func WithEnforceAuthentication\(enforceAuthentication bool\) Option](<#WithEnforceAuthentication>)
  - [func WithEnforceSecureConnection\(enforceSecureConnection bool\) Option](<#WithEnforceSecureConnection>)
  - [func WithHostname\(hostname string\) Option](<#WithHostname>)
  - [func WithImplicitTLS\(implicitTLS bool\) Option](<#WithImplicitTLS>)
  - [func WithLogger\(logger \*slog.Logger\) Option](<#WithLogger>)
  - [func WithMaxLineLength\(maxLineLength int\) Option](<#WithMaxLineLength>)
  - [func WithMaxMessageBytes\(maxMessageBytes int64\) Option](<#WithMaxMessageBytes>)
  - [func WithMaxRecipients\(maxRecipients int\) Option](<#WithMaxRecipients>)
  - [func WithNetwork\(network string\) Option](<#WithNetwork>)
  - [func WithReadTimeout\(readTimeout time.Duration\) Option](<#WithReadTimeout>)
  - [func WithReaderSize\(readerSize int\) Option](<#WithReaderSize>)
  - [func WithTLSConfig\(tlsConfig \*tls.Config\) Option](<#WithTLSConfig>)
  - [func WithWriteTimeout\(writeTimeout time.Duration\) Option](<#WithWriteTimeout>)
  - [func WithWriterSize\(writerSize int\) Option](<#WithWriterSize>)
- [type Server](<#Server>)
  - [func New\(opts ...Option\) \*Server](<#New>)
  - [func \(s \*Server\) Backend\(\) Backend](<#Server.Backend>)
  - [func \(s \*Server\) Close\(\) error](<#Server.Close>)
  - [func \(s \*Server\) Listen\(\) \(net.Listener, error\)](<#Server.Listen>)
  - [func \(s \*Server\) ListenAndServe\(ctx context.Context\) error](<#Server.ListenAndServe>)
  - [func \(s \*Server\) Serve\(ctx context.Context, l net.Listener\) error](<#Server.Serve>)
  - [func \(s \*Server\) Shutdown\(ctx context.Context\) error](<#Server.Shutdown>)
- [type Session](<#Session>)


## Variables

<a name="ErrServerClosed"></a>ErrServerClosed occurs if a server is already closed.

```go
var ErrServerClosed = errors.New("smtp: server already closed")
```

<a name="Backend"></a>
## type Backend

Backend is a SMTP server backend.

```go
type Backend interface {
    NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)
}
```

<a name="BackendFunc"></a>
## type BackendFunc

BackendFunc is an adapter to allow the use of an ordinary function as a Backend.

```go
type BackendFunc func(ctx context.Context, c *Conn) (context.Context, Session, error)
```

<a name="BackendFunc.NewSession"></a>
### func \(BackendFunc\) NewSession

```go
func (f BackendFunc) NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)
```

NewSession calls f\(c\). The returning context is used in the session.

<a name="Conn"></a>
## type Conn

Conn is a connection inside a smtp server.

```go
type Conn struct {
    // contains filtered or unexported fields
}
```

<a name="Conn.Close"></a>
### func \(\*Conn\) Close

```go
func (c *Conn) Close(err error)
```

Close closes the connection.

<a name="Conn.Conn"></a>
### func \(\*Conn\) Conn

```go
func (c *Conn) Conn() net.Conn
```

Conn returns the connection.

<a name="Conn.Hostname"></a>
### func \(\*Conn\) Hostname

```go
func (c *Conn) Hostname() string
```

Hostname returns the name of the connected client.

<a name="Conn.IsTLS"></a>
### func \(\*Conn\) IsTLS

```go
func (c *Conn) IsTLS() bool
```

IsTLS returns if the connection is encrypted by tls.

<a name="Conn.Mechanisms"></a>
### func \(\*Conn\) Mechanisms

```go
func (c *Conn) Mechanisms() []string
```

Mechanisms returns the allowed auth mechanism for this connection.

<a name="Conn.Server"></a>
### func \(\*Conn\) Server

```go
func (c *Conn) Server() *Server
```

Server returns the server this connection comes from.

<a name="Conn.TLSConnectionState"></a>
### func \(\*Conn\) TLSConnectionState

```go
func (c *Conn) TLSConnectionState() (tls.ConnectionState, bool)
```

TLSConnectionState returns the connection's TLS connection state. Zero values are returned if the connection doesn't use TLS.

<a name="Option"></a>
## type Option

Option is an option for the server.

```go
type Option func(*Server)
```

<a name="WithAddr"></a>
### func WithAddr

```go
func WithAddr(addr string) Option
```

WithAddr sets addr.

<a name="WithBackend"></a>
### func WithBackend

```go
func WithBackend(backend Backend) Option
```

WithBackend sets the backend.

<a name="WithEnableBINARYMIME"></a>
### func WithEnableBINARYMIME

```go
func WithEnableBINARYMIME(enableBINARYMIME bool) Option
```

WithEnableBINARYMIME sets EnableBINARYMIME.

<a name="WithEnableCHUNKING"></a>
### func WithEnableCHUNKING

```go
func WithEnableCHUNKING(enableCHUNKING bool) Option
```

WithEnableCHUNKING sets EnableCHUNKING.

<a name="WithEnableDSN"></a>
### func WithEnableDSN

```go
func WithEnableDSN(enableDSN bool) Option
```

WithEnableDSN sets EnableDSN.

<a name="WithEnableREQUIRETLS"></a>
### func WithEnableREQUIRETLS

```go
func WithEnableREQUIRETLS(enableREQUIRETLS bool) Option
```

WithEnableREQUIRETLS sets EnableREQUIRETLS.

<a name="WithEnableSMTPUTF8"></a>
### func WithEnableSMTPUTF8

```go
func WithEnableSMTPUTF8(enableSMTPUTF8 bool) Option
```

WithEnableSMTPUTF8 sets EnableSMTPUTF8.

<a name="WithEnableXOORG"></a>
### func WithEnableXOORG

```go
func WithEnableXOORG(enableXOORG bool) Option
```

WithEnableXOORG enables xoorg.

<a name="WithEnforceAuthentication"></a>
### func WithEnforceAuthentication

```go
func WithEnforceAuthentication(enforceAuthentication bool) Option
```

WithEnforceAuthentication enforces authentication before mail usage.

<a name="WithEnforceSecureConnection"></a>
### func WithEnforceSecureConnection

```go
func WithEnforceSecureConnection(enforceSecureConnection bool) Option
```

WithEnforceSecureConnection enforces implicit TLS or STARTTLS.

<a name="WithHostname"></a>
### func WithHostname

```go
func WithHostname(hostname string) Option
```

WithHostname sets the domain.

<a name="WithImplicitTLS"></a>
### func WithImplicitTLS

```go
func WithImplicitTLS(implicitTLS bool) Option
```

WithImplicitTLS sets implicitTLS.

<a name="WithLogger"></a>
### func WithLogger

```go
func WithLogger(logger *slog.Logger) Option
```

WithLogger sets the backend.

<a name="WithMaxLineLength"></a>
### func WithMaxLineLength

```go
func WithMaxLineLength(maxLineLength int) Option
```

WithMaxLineLength sets the max length per line.

<a name="WithMaxMessageBytes"></a>
### func WithMaxMessageBytes

```go
func WithMaxMessageBytes(maxMessageBytes int64) Option
```

WithMaxMessageBytes sets the max message size.

<a name="WithMaxRecipients"></a>
### func WithMaxRecipients

```go
func WithMaxRecipients(maxRecipients int) Option
```

WithMaxRecipients sets the max recipients per mail.

<a name="WithNetwork"></a>
### func WithNetwork

```go
func WithNetwork(network string) Option
```

WithNetwork sets the network.

<a name="WithReadTimeout"></a>
### func WithReadTimeout

```go
func WithReadTimeout(readTimeout time.Duration) Option
```

WithReadTimeout sets the read timeout.

<a name="WithReaderSize"></a>
### func WithReaderSize

```go
func WithReaderSize(readerSize int) Option
```

WithReaderSize sets ReaderSize.

<a name="WithTLSConfig"></a>
### func WithTLSConfig

```go
func WithTLSConfig(tlsConfig *tls.Config) Option
```

WithTLSConfig sets certificate.

<a name="WithWriteTimeout"></a>
### func WithWriteTimeout

```go
func WithWriteTimeout(writeTimeout time.Duration) Option
```

WithWriteTimeout sets the write timeout.

<a name="WithWriterSize"></a>
### func WithWriterSize

```go
func WithWriterSize(writerSize int) Option
```

WithWriterSize sets WriterSize.

<a name="Server"></a>
## type Server

Server implements a SMTP server.

```go
type Server struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>

ExampleServer runs an example SMTP server.

It can be tested manually with e.g. netcat:

```
> netcat -C localhost 1025
EHLO localhost
AUTH PLAIN
AHVzZXJuYW1lAHBhc3N3b3Jk
MAIL FROM:<root@nsa.gov>
RCPT TO:<root@gchq.gov.uk>
DATA
Hey <3
.
```

```go
package main

import (
	"context"
	"crypto/tls"
	"errors"
	"io"
	"log"
	"log/slog"
	"time"

	"github.com/uponusolutions/go-sasl"
	"github.com/uponusolutions/go-smtp"
	"github.com/uponusolutions/go-smtp/server"
)

// The Backend implements SMTP server methods.
type Backend struct{}

// NewSession is called after client greeting (EHLO, HELO).
func (*Backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error) {
	return ctx, &Session{}, nil
}

// A Session is returned after successful login.
type Session struct {
	auth bool
}

// Logger returns nil.
func (*Session) Logger(_ context.Context) *slog.Logger {
	return nil
}

// AuthMechanisms returns a slice of available auth mechanisms; only PLAIN is
// supported in this example.
func (*Session) AuthMechanisms(_ context.Context) []string {
	return []string{sasl.Plain}
}

// Auth is the handler for supported authenticators.
func (s *Session) Auth(_ context.Context, _ string) (sasl.Server, error) {
	return sasl.NewPlainServer(func(_, username, password string) error {
		if username != "username" || password != "password" {
			return errors.New("Invalid username or password")
		}
		s.auth = true
		return nil
	}), nil
}

func (s *Session) Mail(_ context.Context, from string, _ *smtp.MailOptions) error {
	if !s.auth {
		return smtp.ErrAuthRequired
	}
	log.Println("Mail from:", from)
	return nil
}

func (*Session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error {
	return nil
}

func (s *Session) Rcpt(_ context.Context, to string, _ *smtp.RcptOptions) error {
	if !s.auth {
		return smtp.ErrAuthRequired
	}
	log.Println("Rcpt to:", to)
	return nil
}

func (*Session) STARTTLS(_ context.Context, tls *tls.Config) (*tls.Config, error) {
	return tls, nil
}

func (s *Session) Data(_ context.Context, r func() io.Reader) (string, error) {
	if !s.auth {
		return "", smtp.ErrAuthRequired
	}

	b, err := io.ReadAll(r())
	if err != nil {
		return "", err
	}
	log.Println("Data:", string(b))
	return "", nil
}

func (*Session) Reset(ctx context.Context, _ bool) (context.Context, error) {
	return ctx, nil
}

func (*Session) Close(_ context.Context, _ error) {
}

// ExampleServer runs an example SMTP server.
//
// It can be tested manually with e.g. netcat:
//
//	> netcat -C localhost 1025
//	EHLO localhost
//	AUTH PLAIN
//	AHVzZXJuYW1lAHBhc3N3b3Jk
//	MAIL FROM:<root@nsa.gov>
//	RCPT TO:<root@gchq.gov.uk>
//	DATA
//	Hey <3
//	.
func main() {
	be := &Backend{}
	addr := "localhost:1025"

	s := server.New(
		server.WithBackend(be),
		server.WithAddr(addr),
		server.WithHostname("localhost"),
		server.WithWriteTimeout(10*time.Second),
		server.WithReadTimeout(10*time.Second),
		server.WithMaxMessageBytes(1024*1024),
		server.WithMaxRecipients(50),
	)

	log.Println("Starting server at", addr)
	if err := s.ListenAndServe(context.Background()); err != nil {
		log.Fatal(err)
	}
}
```

</p>
</details>

<a name="New"></a>
### func New

```go
func New(opts ...Option) *Server
```

New creates a new SMTP server.

<a name="Server.Backend"></a>
### func \(\*Server\) Backend

```go
func (s *Server) Backend() Backend
```

Backend returns the servers Backend.

<a name="Server.Close"></a>
### func \(\*Server\) Close

```go
func (s *Server) Close() error
```

Close immediately closes all active listeners and connections.

Close returns any error returned from closing the server's underlying listener\(s\).

<a name="Server.Listen"></a>
### func \(\*Server\) Listen

```go
func (s *Server) Listen() (net.Listener, error)
```

Listen listens on the network address s.Addr to handle requests on incoming connections.

If s.Addr is blank and LMTP is disabled, ":smtp" is used.

<a name="Server.ListenAndServe"></a>
### func \(\*Server\) ListenAndServe

```go
func (s *Server) ListenAndServe(ctx context.Context) error
```

ListenAndServe listens on the network address s.Addr and then calls Serve to handle requests on incoming connections.

If s.Addr is blank and LMTP is disabled, ":smtp" is used.

<a name="Server.Serve"></a>
### func \(\*Server\) Serve

```go
func (s *Server) Serve(ctx context.Context, l net.Listener) error
```

Serve accepts incoming connections on the Listener l.

<a name="Server.Shutdown"></a>
### func \(\*Server\) Shutdown

```go
func (s *Server) Shutdown(ctx context.Context) error
```

Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener\(s\).

<a name="Session"></a>
## type Session

Session is used by servers to respond to an SMTP client.

The methods are called when the remote client issues the matching command.

```go
type Session interface {
    // Discard currently processed message.
    // The returning context replaces the context used in the current session.
    // Upgrade is true when the reset is called after a tls upgrade.
    Reset(ctx context.Context, upgrade bool) (context.Context, error)

    // Free all resources associated with session.
    // Error is set if an error occurred during session or connection.
    // Close is always called after the session is done.
    Close(ctx context.Context, err error)

    // Returns logger to use when an error occurs inside a session.
    // If no logger is returned the default *slog.Logger is used.
    Logger(ctx context.Context) *slog.Logger

    // Set return path for currently processed message.
    Mail(ctx context.Context, from string, opts *smtp.MailOptions) error

    // Add recipient for currently processed message.
    Rcpt(ctx context.Context, to string, opts *smtp.RcptOptions) error

    // Verify checks the validity of an email address on the server.
    // If error is nil then smtp code 252 is send
    // if error is smtp status then the smtp status is send
    // else internal server error is returned and connection is closed
    Verify(ctx context.Context, addr string, opts *smtp.VrfyOptions) error

    // Set currently processed message contents and send it.
    // If r is called then the data must be consumed completely before returning.
    // The queuedid must not be unique.
    Data(ctx context.Context, r func() io.Reader) (queueid string, err error)

    // AuthMechanisms returns valid auth mechanism.
    // Nil or an empty list means no authentication mechanism is allowed.
    AuthMechanisms(ctx context.Context) []string

    // Auth returns a matching sasl server for the given mech.
    Auth(ctx context.Context, mech string) (sasl.Server, error)

    // STARTTLS returns a valid *tls.Config.
    // Is called with the default tls config and the returned tls config is used in the tls upgrade.
    // If the tls.Config is nil or an error is returned, the tls upgrade is aborted and the connection closed.
    // The *tls.Config received must not be changed.
    STARTTLS(ctx context.Context, tls *tls.Config) (*tls.Config, error)
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->