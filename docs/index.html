<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

<h1>smtp</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp&quot;
</code></pre>

<p>Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</p>

<p>It also implements the following extensions:</p>

<ul>
<li>8BITMIME (RFC 1652)</li>
<li>AUTH (RFC 2554)</li>
<li>STARTTLS (RFC 3207)</li>
<li>ENHANCEDSTATUSCODES (RFC 2034)</li>
<li>SMTPUTF8 (RFC 6531)</li>
<li>REQUIRETLS (RFC 8689)</li>
<li>CHUNKING (RFC 3030)</li>
<li>BINARYMIME (RFC 3030)</li>
<li>DSN (RFC 3461, RFC 6533)</li>
</ul>

<p>LMTP (RFC 2033) is also supported.</p>

<p>Additional extensions may be handled by other packages.</p>

<h2>Index</h2>

<ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#ParseBATV">func ParseBATV(src string) string</a></li>
<li><a href="#ParseSRS">func ParseSRS(src string) string</a></li>
<li><a href="#ParseSender">func ParseSender(src string) string</a></li>
<li><a href="#Timeout">func Timeout(conn net.Conn, duration time.Duration) func()</a></li>
<li><a href="#BodyType">type BodyType</a></li>
<li><a href="#DSNAddressType">type DSNAddressType</a></li>
<li><a href="#DSNNotify">type DSNNotify</a></li>
<li><a href="#DSNReturn">type DSNReturn</a></li>
<li><a href="#EnhancedCode">type EnhancedCode</a></li>
<li><a href="#MailOptions">type MailOptions</a></li>
<li><a href="#RcptOptions">type RcptOptions</a></li>
<li><a href="#Status">type Status</a>

<ul>
<li><a href="#NewStatus">func NewStatus(code int, enhCode EnhancedCode, msg string) *Status</a></li>
<li><a href="#Status.Error">func (err *Status) Error() string</a></li>
<li><a href="#Status.Permanent">func (err *Status) Permanent() bool</a></li>
<li><a href="#Status.Positive">func (err *Status) Positive() bool</a></li>
<li><a href="#Status.Temporary">func (err *Status) Temporary() bool</a></li>
</ul></li>
<li><a href="#VrfyOptions">type VrfyOptions</a></li>
</ul>

<h2>Variables</h2>

<p><a name="Reset"></a></p>

<pre><code class="language-go">var (
    // Reset is returned by Reader passed to Data function if client does not
    // send another BDAT command and instead issues RSET command.
    Reset = &amp;Status{
        Code:         250,
        EnhancedCode: EnhancedCode{2, 0, 0},
        Message:      &quot;Session reset&quot;,
    }
    // VRFY default return.
    VRFY = &amp;Status{
        Code:         252,
        EnhancedCode: EnhancedCode{2, 5, 0},
        Message:      &quot;Cannot VRFY user, but will accept message&quot;,
    }
    // Noop default return.
    Noop = &amp;Status{
        Code:         250,
        EnhancedCode: EnhancedCode{2, 0, 0},
        Message:      &quot;I have successfully done nothing&quot;,
    }
    // Quit is returned by Reader passed to Data function if client does not
    // send another BDAT command and instead issues QUIT command.
    Quit = &amp;Status{
        Code:         221,
        EnhancedCode: EnhancedCode{2, 0, 0},
        Message:      &quot;Bye&quot;,
    }
    // ErrConnection is returned if a connection error occurs.
    ErrConnection = &amp;Status{
        Code:         421,
        EnhancedCode: EnhancedCode{4, 4, 0},
        Message:      &quot;Connection error, sorry&quot;,
    }
    // ErrDataTooLarge is returned if the maximum message size is exceeded.
    ErrDataTooLarge = &amp;Status{
        Code:         552,
        EnhancedCode: EnhancedCode{5, 3, 4},
        Message:      &quot;Maximum message size exceeded&quot;,
    }
    // ErrAuthFailed is returned if the authentication failed.
    ErrAuthFailed = &amp;Status{
        Code:         535,
        EnhancedCode: EnhancedCode{5, 7, 8},
        Message:      &quot;Authentication failed&quot;,
    }
    // ErrAuthRequired is returned if the authentication is required.
    ErrAuthRequired = &amp;Status{
        Code:         502,
        EnhancedCode: EnhancedCode{5, 7, 0},
        Message:      &quot;Please authenticate first&quot;,
    }
    // ErrAuthUnsupported is returned if the authentication is not supported.
    ErrAuthUnsupported = &amp;Status{
        Code:         502,
        EnhancedCode: EnhancedCode{5, 7, 0},
        Message:      &quot;Authentication not supported&quot;,
    }
    // ErrAuthUnknownMechanism is returned if the authentication unsupported.
    ErrAuthUnknownMechanism = &amp;Status{
        Code:         504,
        EnhancedCode: EnhancedCode{5, 7, 4},
        Message:      &quot;Unsupported authentication mechanism&quot;,
    }
    // ErrNoRecipients is returned if no recipients are set.
    ErrNoRecipients = &amp;Status{
        Code:         502,
        EnhancedCode: EnhancedCode{5, 5, 1},
        Message:      &quot;Missing RCPT TO command.&quot;,
    }
)
</code></pre>

<p><a name="EnhancedCodeNotSet"></a>EnhancedCodeNotSet is a nil value of EnhancedCode field in smtp, used to indicate that backend failed to provide enhanced status code. X.0.0 will be used (X is derived from error code).</p>

<pre><code class="language-go">var EnhancedCodeNotSet = EnhancedCode{0, 0, 0}
</code></pre>

<p><a name="NoEnhancedCode"></a>NoEnhancedCode is used to indicate that enhanced error code should not be included in response.</p>

<p>Note that RFC 2034 requires an enhanced code to be included in all 2xx, 4xx and 5xx responses. This constant is exported for use by extensions, you should probably use EnhancedCodeNotSet instead.</p>

<pre><code class="language-go">var NoEnhancedCode = EnhancedCode{-1, -1, -1}
</code></pre>

<p><a name="ParseBATV"></a></p>

<h2>func ParseBATV</h2>

<pre><code class="language-go">func ParseBATV(src string) string
</code></pre>

<p>ParseBATV parses src to extract a BATV address. When BATV extration is not possible/needed src is returned.</p>

<p><a name="ParseSRS"></a></p>

<h2>func ParseSRS</h2>

<pre><code class="language-go">func ParseSRS(src string) string
</code></pre>

<p>ParseSRS parses src to extract the forwarding sender from SRS (Exchange Online). When SRS extration is not possible/needed src is returned.</p>

<p><a name="ParseSender"></a></p>

<h2>func ParseSender</h2>

<pre><code class="language-go">func ParseSender(src string) string
</code></pre>

<p>ParseSender combines ParseSRS and ParseBATV.</p>

<p><a name="Timeout"></a></p>

<h2>func Timeout</h2>

<pre><code class="language-go">func Timeout(conn net.Conn, duration time.Duration) func()
</code></pre>

<p>Timeout sets a timeout by deadline to the connection and relieves it when returning func is used.</p>

<p><a name="BodyType"></a></p>

<h2>type BodyType</h2>

<p>BodyType describes the type of the body.</p>

<pre><code class="language-go">type BodyType string
</code></pre>

<p><a name="Body7Bit"></a></p>

<pre><code class="language-go">const (
    // Body7Bit means the body type is 7BIT
    Body7Bit BodyType = &quot;7BIT&quot;
    // Body8BitMIME means the body type is 8BITMIME
    Body8BitMIME BodyType = &quot;8BITMIME&quot;
    // BodyBinaryMIME means the body type is BINARYMIME
    BodyBinaryMIME BodyType = &quot;BINARYMIME&quot;
)
</code></pre>

<p><a name="DSNAddressType"></a></p>

<h2>type DSNAddressType</h2>

<p>DSNAddressType describes the DSN address type.</p>

<pre><code class="language-go">type DSNAddressType string
</code></pre>

<p><a name="DSNAddressTypeRFC822"></a></p>

<pre><code class="language-go">const (
    // DSNAddressTypeRFC822 means that the DSN address type is RFC822.
    DSNAddressTypeRFC822 DSNAddressType = &quot;RFC822&quot;
    // DSNAddressTypeUTF8 means that the DSN address type is UTF-8.
    DSNAddressTypeUTF8 DSNAddressType = &quot;UTF-8&quot;
)
</code></pre>

<p><a name="DSNNotify"></a></p>

<h2>type DSNNotify</h2>

<p>DSNNotify describes the DSN notify.</p>

<pre><code class="language-go">type DSNNotify string
</code></pre>

<p><a name="DSNNotifyNever"></a></p>

<pre><code class="language-go">const (
    // DSNNotifyNever sets the DSN notify to never.
    DSNNotifyNever DSNNotify = &quot;NEVER&quot;
    // DSNNotifyDelayed sets the DSN notify to delay.
    DSNNotifyDelayed DSNNotify = &quot;DELAY&quot;
    // DSNNotifyFailure sets the DSN notify to failure.
    DSNNotifyFailure DSNNotify = &quot;FAILURE&quot;
    // DSNNotifySuccess sets the DSN notify to succes.
    DSNNotifySuccess DSNNotify = &quot;SUCCESS&quot;
)
</code></pre>

<p><a name="DSNReturn"></a></p>

<h2>type DSNReturn</h2>

<p>DSNReturn describes the DSN return.</p>

<pre><code class="language-go">type DSNReturn string
</code></pre>

<p><a name="DSNReturnFull"></a></p>

<pre><code class="language-go">const (
    // DSNReturnFull means DNS return is full.
    DSNReturnFull DSNReturn = &quot;FULL&quot;
    // DSNReturnHeaders means DNS return is hdrs.
    DSNReturnHeaders DSNReturn = &quot;HDRS&quot;
)
</code></pre>

<p><a name="EnhancedCode"></a></p>

<h2>type EnhancedCode</h2>

<p>EnhancedCode is the SMTP enhanced code</p>

<pre><code class="language-go">type EnhancedCode [3]int
</code></pre>

<p><a name="MailOptions"></a></p>

<h2>type MailOptions</h2>

<p>MailOptions contains parameters for the MAIL command.</p>

<pre><code class="language-go">type MailOptions struct {
    // Value of BODY= argument, 7BIT, 8BITMIME or BINARYMIME.
    Body BodyType

    // Size of the body. Can be 0 if not specified by client.
    Size int64

    // TLS is required for the message transmission.
    //
    // The message should be rejected if it can't be transmitted
    // with TLS.
    RequireTLS bool

    // The message envelope or message header contains UTF-8-encoded strings.
    // This flag is set by SMTPUTF8-aware (RFC 6531) client.
    UTF8 bool

    // Value of RET= argument, FULL or HDRS.
    Return DSNReturn

    // Envelope identifier set by the client.
    EnvelopeID string

    // Accepted Domain from Exchange Online, e.g. from OutgoingConnector
    XOORG *string

    // The authorization identity asserted by the message sender in decoded
    // form with angle brackets stripped.
    //
    // nil value indicates missing AUTH, non-nil empty string indicates
    // AUTH=&lt;&gt;.
    //
    // Defined in RFC 4954.
    Auth *string
}
</code></pre>

<p><a name="RcptOptions"></a></p>

<h2>type RcptOptions</h2>

<p>RcptOptions contains parameters for the RCPT command.</p>

<pre><code class="language-go">type RcptOptions struct {
    // Value of NOTIFY= argument, NEVER or a combination of either of
    // DELAY, FAILURE, SUCCESS.
    Notify []DSNNotify

    // Original recipient set by client.
    OriginalRecipientType DSNAddressType
    OriginalRecipient     string
}
</code></pre>

<p><a name="Status"></a></p>

<h2>type Status</h2>

<p>Status specifies the error code, enhanced error code (if any) and message returned by the server.</p>

<pre><code class="language-go">type Status struct {
    Code         int
    EnhancedCode EnhancedCode
    Message      string
}
</code></pre>

<p><a name="NewStatus"></a></p>

<h3>func NewStatus</h3>

<pre><code class="language-go">func NewStatus(code int, enhCode EnhancedCode, msg string) *Status
</code></pre>

<p>NewStatus creates a new status.</p>

<p><a name="Status.Error"></a></p>

<h3>func (*Status) Error</h3>

<pre><code class="language-go">func (err *Status) Error() string
</code></pre>

<p>Error returns a error string.</p>

<p><a name="Status.Permanent"></a></p>

<h3>func (*Status) Permanent</h3>

<pre><code class="language-go">func (err *Status) Permanent() bool
</code></pre>

<p>Permanent returns true if the status code is 5xx.</p>

<p><a name="Status.Positive"></a></p>

<h3>func (*Status) Positive</h3>

<pre><code class="language-go">func (err *Status) Positive() bool
</code></pre>

<p>Positive returns true if the status code is 2xx.</p>

<p><a name="Status.Temporary"></a></p>

<h3>func (*Status) Temporary</h3>

<pre><code class="language-go">func (err *Status) Temporary() bool
</code></pre>

<p>Temporary returns true if the status code is 4xx.</p>

<p><a name="VrfyOptions"></a></p>

<h2>type VrfyOptions</h2>

<p>VrfyOptions contains parameters for the VRFY command.</p>

<pre><code class="language-go">type VrfyOptions struct {
    // The message envelope or message header contains UTF-8-encoded strings.
    // This flag is set by SMTPUTF8-aware (RFC 6531) client.
    UTF8 bool
}
</code></pre>

<h1>client</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/client&quot;
</code></pre>

<h2>Index</h2>

<ul>
<li><a href="#Client">type Client</a>

<ul>
<li><a href="#New">func New(opts &hellip;Option) *Client</a></li>
<li><a href="#Client.Auth">func (c *Client) Auth(a sasl.Client) error</a></li>
<li><a href="#Client.Close">func (c *Client) Close() error</a></li>
<li><a href="#Client.Connect">func (c *Client) Connect(ctx context.Context) error</a></li>
<li><a href="#Client.Data">func (c *Client) Data() (*DataCloser, error)</a></li>
<li><a href="#Client.Extension">func (c *Client) Extension(ext string) (bool, string)</a></li>
<li><a href="#Client.Mail">func (c *Client) Mail(from string, opts *MailOptions) error</a></li>
<li><a href="#Client.MaxMessageSize">func (c *Client) MaxMessageSize() (size int, ok bool)</a></li>
<li><a href="#Client.Noop">func (c *Client) Noop() error</a></li>
<li><a href="#Client.Quit">func (c *Client) Quit() error</a></li>
<li><a href="#Client.Rcpt">func (c *Client) Rcpt(to string, opts *smtp.RcptOptions) error</a></li>
<li><a href="#Client.Reset">func (c *Client) Reset() error</a></li>
<li><a href="#Client.Send">func (c *Client) Send(from string, rcpt []string, msg []byte) error</a></li>
<li><a href="#Client.SendMail">func (c *Client) SendMail(from string, rcpt []string, in io.Reader) (code int, msg string, err error)</a></li>
<li><a href="#Client.ServerAddress">func (c *Client) ServerAddress() string</a></li>
<li><a href="#Client.ServerAddresses">func (c *Client) ServerAddresses() [][]string</a></li>
<li><a href="#Client.ServerName">func (c *Client) ServerName() string</a></li>
<li><a href="#Client.SetXOORG">func (c *Client) SetXOORG(xoorg *string)</a></li>
<li><a href="#Client.SupportsAuth">func (c *Client) SupportsAuth(mech string) bool</a></li>
<li><a href="#Client.TLSConnectionState">func (c *Client) TLSConnectionState() (tls.ConnectionState, bool)</a></li>
<li><a href="#Client.Verify">func (c *Client) Verify(addr string, opts *VrfyOptions) error</a></li>
</ul></li>
<li><a href="#DataCloser">type DataCloser</a>

<ul>
<li><a href="#DataCloser.Close">func (d *DataCloser) Close() error</a></li>
<li><a href="#DataCloser.CloseWithResponse">func (d *DataCloser) CloseWithResponse() (code int, msg string, err error)</a></li>
</ul></li>
<li><a href="#MailOptions">type MailOptions</a></li>
<li><a href="#Option">type Option</a>

<ul>
<li><a href="#WithCommandTimeout">func WithCommandTimeout(commandTimeout time.Duration) Option</a></li>
<li><a href="#WithDialTimeout">func WithDialTimeout(dialTimeout time.Duration) Option</a></li>
<li><a href="#WithLocalName">func WithLocalName(localName string) Option</a></li>
<li><a href="#WithMailOptions">func WithMailOptions(mailOptions MailOptions) Option</a></li>
<li><a href="#WithMaxLineLength">func WithMaxLineLength(maxLineLength int) Option</a></li>
<li><a href="#WithReaderSize">func WithReaderSize(readerSize int) Option</a></li>
<li><a href="#WithSASLClient">func WithSASLClient(cl sasl.Client) Option</a></li>
<li><a href="#WithSecurity">func WithSecurity(security Security) Option</a></li>
<li><a href="#WithServerAddressIndex">func WithServerAddressIndex(index int) Option</a></li>
<li><a href="#WithServerAddresses">func WithServerAddresses(addrs &hellip;string) Option</a></li>
<li><a href="#WithServerAddressesPrio">func WithServerAddressesPrio(addrs &hellip;[]string) Option</a></li>
<li><a href="#WithSubmissionTimeout">func WithSubmissionTimeout(submissionTimeout time.Duration) Option</a></li>
<li><a href="#WithTLSConfig">func WithTLSConfig(cfg *tls.Config) Option</a></li>
<li><a href="#WithTlsHandshakeTimeout">func WithTlsHandshakeTimeout(tlsHandshakeTimeout time.Duration) Option</a></li>
<li><a href="#WithWriterSize">func WithWriterSize(writerSize int) Option</a></li>
</ul></li>
<li><a href="#Security">type Security</a></li>
<li><a href="#UTF8">type UTF8</a></li>
<li><a href="#VrfyOptions">type VrfyOptions</a></li>
</ul>

<p><a name="Client"></a></p>

<h2>type Client</h2>

<p>Client is an SMTP client. It sends one or more mails to a SMTP server over a single connection. TODO: Add context support.</p>

<pre><code class="language-go">type Client struct {
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="New"></a></p>

<h3>func New</h3>

<pre><code class="language-go">func New(opts ...Option) *Client
</code></pre>

<p>New returns a new SMTP client. When not set via options the address 127.0.0.1:25 is used. When not set via options a default tls.Config is used.</p>

<p><a name="Client.Auth"></a></p>

<h3>func (*Client) Auth</h3>

<pre><code class="language-go">func (c *Client) Auth(a sasl.Client) error
</code></pre>

<p>Auth authenticates a client using the provided authentication mechanism. Only servers that advertise the AUTH extension support this function.</p>

<p>If server returns an error, it will be of type *smtp.</p>

<p><a name="Client.Close"></a></p>

<h3>func (*Client) Close</h3>

<pre><code class="language-go">func (c *Client) Close() error
</code></pre>

<p>Close closes the connection.</p>

<p><a name="Client.Connect"></a></p>

<h3>func (*Client) Connect</h3>

<pre><code class="language-go">func (c *Client) Connect(ctx context.Context) error
</code></pre>

<p>Connect connects to one of the available SMTP server. When server supports auth and clients SaslClient is set, auth is called. Security is enforced like configured (Plain, TLS, StartTLS or PreferStartTLS) If an error occures, the connection is closed if open.</p>

<p><a name="Client.Data"></a></p>

<h3>func (*Client) Data</h3>

<pre><code class="language-go">func (c *Client) Data() (*DataCloser, error)
</code></pre>

<p>Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to Rcpt.</p>

<p>If server returns an error, it will be of type *smtp.</p>

<p><a name="Client.Extension"></a></p>

<h3>func (*Client) Extension</h3>

<pre><code class="language-go">func (c *Client) Extension(ext string) (bool, string)
</code></pre>

<p>Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension.</p>

<p><a name="Client.Mail"></a></p>

<h3>func (*Client) Mail</h3>

<pre><code class="language-go">func (c *Client) Mail(from string, opts *MailOptions) error
</code></pre>

<p>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</p>

<p>If opts is not nil, MAIL arguments provided in the structure will be added to the command. Handling of unsupported options depends on the extension.</p>

<p>If server returns an error, it will be of type *smtp.</p>

<p><a name="Client.MaxMessageSize"></a></p>

<h3>func (*Client) MaxMessageSize</h3>

<pre><code class="language-go">func (c *Client) MaxMessageSize() (size int, ok bool)
</code></pre>

<p>MaxMessageSize returns the maximum message size accepted by the server. 0 means unlimited.</p>

<p>If the server doesn&rsquo;t convey this information, ok = false is returned.</p>

<p><a name="Client.Noop"></a></p>

<h3>func (*Client) Noop</h3>

<pre><code class="language-go">func (c *Client) Noop() error
</code></pre>

<p>Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.</p>

<p><a name="Client.Quit"></a></p>

<h3>func (*Client) Quit</h3>

<pre><code class="language-go">func (c *Client) Quit() error
</code></pre>

<p>Quit sends the QUIT command and closes the connection to the server. If Quit fails the connection will still be closed.</p>

<p><a name="Client.Rcpt"></a></p>

<h3>func (*Client) Rcpt</h3>

<pre><code class="language-go">func (c *Client) Rcpt(to string, opts *smtp.RcptOptions) error
</code></pre>

<p>Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.</p>

<p>If opts is not nil, RCPT arguments provided in the structure will be added to the command. Handling of unsupported options depends on the extension.</p>

<p>If server returns an error, it will be of type *smtp.</p>

<p><a name="Client.Reset"></a></p>

<h3>func (*Client) Reset</h3>

<pre><code class="language-go">func (c *Client) Reset() error
</code></pre>

<p>Reset sends the RSET command to the server, aborting the current mail transaction.</p>

<p><a name="Client.Send"></a></p>

<h3>func (*Client) Send</h3>

<pre><code class="language-go">func (c *Client) Send(from string, rcpt []string, msg []byte) error
</code></pre>

<p>Send implements enmime.Sender interface.</p>

<p><a name="Client.SendMail"></a></p>

<h3>func (*Client) SendMail</h3>

<pre><code class="language-go">func (c *Client) SendMail(from string, rcpt []string, in io.Reader) (code int, msg string, err error)
</code></pre>

<p>SendMail will use an existing connection to send an email from address from, to addresses to, with message r.</p>

<p>This function does not start TLS, nor does it perform authentication. Use DialStartTLS and Auth before-hand if desirable.</p>

<p>The addresses in the to parameter are the SMTP RCPT addresses.</p>

<p>The r parameter should be an RFC 822-style email with headers first, a blank line, and then the message body. The lines of r should be CRLF terminated. The r headers should usually include fields such as &ldquo;From&rdquo;, &ldquo;To&rdquo;, &ldquo;Subject&rdquo;, and &ldquo;Cc&rdquo;. Sending &ldquo;Bcc&rdquo; messages is accomplished by including an email address in the to parameter but not including it in the r headers.</p>

<p><a name="Client.ServerAddress"></a></p>

<h3>func (*Client) ServerAddress</h3>

<pre><code class="language-go">func (c *Client) ServerAddress() string
</code></pre>

<p>ServerAddress returns the current server address.</p>

<p><a name="Client.ServerAddresses"></a></p>

<h3>func (*Client) ServerAddresses</h3>

<pre><code class="language-go">func (c *Client) ServerAddresses() [][]string
</code></pre>

<p>ServerAddresses returns the server address.</p>

<p><a name="Client.ServerName"></a></p>

<h3>func (*Client) ServerName</h3>

<pre><code class="language-go">func (c *Client) ServerName() string
</code></pre>

<p>ServerName returns the current server name.</p>

<p><a name="Client.SetXOORG"></a></p>

<h3>func (*Client) SetXOORG</h3>

<pre><code class="language-go">func (c *Client) SetXOORG(xoorg *string)
</code></pre>

<p>SetXOORG set xoorg support</p>

<p><a name="Client.SupportsAuth"></a></p>

<h3>func (*Client) SupportsAuth</h3>

<pre><code class="language-go">func (c *Client) SupportsAuth(mech string) bool
</code></pre>

<p>SupportsAuth checks whether an authentication mechanism is supported.</p>

<p><a name="Client.TLSConnectionState"></a></p>

<h3>func (*Client) TLSConnectionState</h3>

<pre><code class="language-go">func (c *Client) TLSConnectionState() (tls.ConnectionState, bool)
</code></pre>

<p>TLSConnectionState returns the client&rsquo;s TLS connection state. The return values are their zero values if STARTTLS did not succeed.</p>

<p><a name="Client.Verify"></a></p>

<h3>func (*Client) Verify</h3>

<pre><code class="language-go">func (c *Client) Verify(addr string, opts *VrfyOptions) error
</code></pre>

<p>Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.</p>

<p>If server returns an error, it will be of type *smtp.</p>

<p><a name="DataCloser"></a></p>

<h2>type DataCloser</h2>

<p>DataCloser implement an io.WriteCloser with the additional CloseWithResponse function.</p>

<pre><code class="language-go">type DataCloser struct {
    io.WriteCloser
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="DataCloser.Close"></a></p>

<h3>func (*DataCloser) Close</h3>

<pre><code class="language-go">func (d *DataCloser) Close() error
</code></pre>

<p>Close closes the data closer.</p>

<p><a name="DataCloser.CloseWithResponse"></a></p>

<h3>func (*DataCloser) CloseWithResponse</h3>

<pre><code class="language-go">func (d *DataCloser) CloseWithResponse() (code int, msg string, err error)
</code></pre>

<p>CloseWithResponse closes the data closer and returns code, msg</p>

<p><a name="MailOptions"></a></p>

<h2>type MailOptions</h2>

<p>MailOptions contains parameters for the MAIL command.</p>

<pre><code class="language-go">type MailOptions struct {
    // Size of the body. Can be 0 if not specified by client.
    Size int64

    // TLS is required for the message transmission.
    //
    // The message should be rejected if it can't be transmitted
    // with TLS.
    RequireTLS bool

    // The message envelope or message header contains UTF-8-encoded strings.
    // This flag is set by SMTPUTF8-aware (RFC 6531) client.
    UTF8 UTF8

    // Value of RET= argument, FULL or HDRS.
    Return smtp.DSNReturn

    // Envelope identifier set by the client.
    EnvelopeID string

    // Accepted Domain from Exchange Online, e.g. from OutgoingConnector
    XOORG *string

    // The authorization identity asserted by the message sender in decoded
    // form with angle brackets stripped.
    //
    // nil value indicates missing AUTH, non-nil empty string indicates
    // AUTH=&lt;&gt;.
    //
    // Defined in RFC 4954.
    Auth *string
}
</code></pre>

<p><a name="Option"></a></p>

<h2>type Option</h2>

<p>Option defines a client option.</p>

<pre><code class="language-go">type Option func(c *Client)
</code></pre>

<p><a name="WithCommandTimeout"></a></p>

<h3>func WithCommandTimeout</h3>

<pre><code class="language-go">func WithCommandTimeout(commandTimeout time.Duration) Option
</code></pre>

<p>WithCommandTimeout sets the command timeout.</p>

<p><a name="WithDialTimeout"></a></p>

<h3>func WithDialTimeout</h3>

<pre><code class="language-go">func WithDialTimeout(dialTimeout time.Duration) Option
</code></pre>

<p>WithDialTimeout sets the dial timeout.</p>

<p><a name="WithLocalName"></a></p>

<h3>func WithLocalName</h3>

<pre><code class="language-go">func WithLocalName(localName string) Option
</code></pre>

<p>WithLocalName sets the HELO local name.</p>

<p><a name="WithMailOptions"></a></p>

<h3>func WithMailOptions</h3>

<pre><code class="language-go">func WithMailOptions(mailOptions MailOptions) Option
</code></pre>

<p>WithMailOptions sets the mail options.</p>

<p><a name="WithMaxLineLength"></a></p>

<h3>func WithMaxLineLength</h3>

<pre><code class="language-go">func WithMaxLineLength(maxLineLength int) Option
</code></pre>

<p>WithMaxLineLength sets the max line length.</p>

<p><a name="WithReaderSize"></a></p>

<h3>func WithReaderSize</h3>

<pre><code class="language-go">func WithReaderSize(readerSize int) Option
</code></pre>

<p>WithReaderSize sets the reader size.</p>

<p><a name="WithSASLClient"></a></p>

<h3>func WithSASLClient</h3>

<pre><code class="language-go">func WithSASLClient(cl sasl.Client) Option
</code></pre>

<p>WithSASLClient sets the SASL client.</p>

<p><a name="WithSecurity"></a></p>

<h3>func WithSecurity</h3>

<pre><code class="language-go">func WithSecurity(security Security) Option
</code></pre>

<p>WithSecurity sets the TLS config.</p>

<p><a name="WithServerAddressIndex"></a></p>

<h3>func WithServerAddressIndex</h3>

<pre><code class="language-go">func WithServerAddressIndex(index int) Option
</code></pre>

<p>WithServerAddressIndex sets the SMTP server index.</p>

<p><a name="WithServerAddresses"></a></p>

<h3>func WithServerAddresses</h3>

<pre><code class="language-go">func WithServerAddresses(addrs ...string) Option
</code></pre>

<p>WithServerAddresses sets the SMTP servers address.</p>

<p><a name="WithServerAddressesPrio"></a></p>

<h3>func WithServerAddressesPrio</h3>

<pre><code class="language-go">func WithServerAddressesPrio(addrs ...[]string) Option
</code></pre>

<p>WithServerAddressesPrio sets the SMTP servers address.</p>

<p><a name="WithSubmissionTimeout"></a></p>

<h3>func WithSubmissionTimeout</h3>

<pre><code class="language-go">func WithSubmissionTimeout(submissionTimeout time.Duration) Option
</code></pre>

<p>WithSubmissionTimeout sets the submission timeout.</p>

<p><a name="WithTLSConfig"></a></p>

<h3>func WithTLSConfig</h3>

<pre><code class="language-go">func WithTLSConfig(cfg *tls.Config) Option
</code></pre>

<p>WithTLSConfig sets the TLS config.</p>

<p><a name="WithTlsHandshakeTimeout"></a></p>

<h3>func WithTlsHandshakeTimeout</h3>

<pre><code class="language-go">func WithTlsHandshakeTimeout(tlsHandshakeTimeout time.Duration) Option
</code></pre>

<p>WithTlsHandshakeTimeout sets tls handshake timeout.</p>

<p><a name="WithWriterSize"></a></p>

<h3>func WithWriterSize</h3>

<pre><code class="language-go">func WithWriterSize(writerSize int) Option
</code></pre>

<p>WithWriterSize sets the reader size.</p>

<p><a name="Security"></a></p>

<h2>type Security</h2>

<p>Security describes how the connection is etablished.</p>

<pre><code class="language-go">type Security int32
</code></pre>

<p><a name="SecurityPreferStartTLS"></a></p>

<pre><code class="language-go">const (
    // SecurityPreferStartTLS tries to use StartTls but fallbacks to plain.
    SecurityPreferStartTLS Security = 0
    // SecurityPlain is always just a plain connection.
    SecurityPlain Security = 1
    // SecurityTLS does a implicit tls connection.
    SecurityTLS Security = 2
    // SecurityStartTLS always does starttls.
    SecurityStartTLS Security = 3
)
</code></pre>

<p><a name="UTF8"></a></p>

<h2>type UTF8</h2>

<p>UTF8 describes how SMTPUTF8 is used.</p>

<pre><code class="language-go">type UTF8 int32
</code></pre>

<p><a name="UTF8Prefer"></a></p>

<pre><code class="language-go">const (
    // UTF8Prefer uses SMTPUTF8 if possible.
    UTF8Prefer UTF8 = 0
    // UTF8Force always uses SMTPUTF8.
    UTF8Force UTF8 = 1
    // UTF8Disabled never uses SMTPUTF8.
    UTF8Disabled UTF8 = 2
)
</code></pre>

<p><a name="VrfyOptions"></a></p>

<h2>type VrfyOptions</h2>

<p>VrfyOptions contains parameters for the VRFY command.</p>

<pre><code class="language-go">type VrfyOptions struct {
    // The message envelope or message header contains UTF-8-encoded strings.
    // This flag is set by SMTPUTF8-aware (RFC 6531) client.
    UTF8 UTF8
}
</code></pre>

<h1>server</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/server&quot;
</code></pre>

<details><summary>Example</summary>
<p>



```go
// Set up authentication information.
auth := sasl.NewPlainClient("", "user@example.com", "password")

// Connect to the server, authenticate, set the sender and recipient,
// and send the email all in one step.
to := []string{"recipient@example.net"}
msg := strings.NewReader("To: recipient@example.net\r\n" +
	"Subject: discount Gophers!\r\n" +
	"\r\n" +
	"This is the email body.\r\n")

c := client.New(
	client.WithServerAddresses("mail.example.com:25"),
	client.WithSASLClient(auth),
)

_, _, err := c.SendMail("sender@example.org", to, msg)
if err != nil {
	log.Fatal(err)
}
```

</p>
</details>

<details><summary>Example (Plain Auth)</summary>
<p>



```go
// hostname is used by PlainAuth to validate the TLS certificate.
hostname := "mail.example.com"
auth := sasl.NewPlainClient("", "user@example.com", "password")

c := client.New(
	client.WithServerAddresses(hostname+":25"),
	client.WithSASLClient(auth),
)

_, _, err := c.SendMail(from, recipients, msg)
if err != nil {
	log.Fatal(err)
}
```

</p>
</details>

<h2>Index</h2>

<ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#Backend">type Backend</a></li>
<li><a href="#BackendFunc">type BackendFunc</a>

<ul>
<li><a href="#BackendFunc.NewSession">func (f BackendFunc) NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)</a></li>
</ul></li>
<li><a href="#Conn">type Conn</a>

<ul>
<li><a href="#Conn.Close">func (c *Conn) Close(err error)</a></li>
<li><a href="#Conn.Conn">func (c *Conn) Conn() net.Conn</a></li>
<li><a href="#Conn.Hostname">func (c *Conn) Hostname() string</a></li>
<li><a href="#Conn.IsTLS">func (c *Conn) IsTLS() bool</a></li>
<li><a href="#Conn.Mechanisms">func (c *Conn) Mechanisms() []string</a></li>
<li><a href="#Conn.Server">func (c *Conn) Server() *Server</a></li>
<li><a href="#Conn.TLSConnectionState">func (c *Conn) TLSConnectionState() (tls.ConnectionState, bool)</a></li>
</ul></li>
<li><a href="#Option">type Option</a>

<ul>
<li><a href="#WithAddr">func WithAddr(addr string) Option</a></li>
<li><a href="#WithBackend">func WithBackend(backend Backend) Option</a></li>
<li><a href="#WithEnableBINARYMIME">func WithEnableBINARYMIME(enableBINARYMIME bool) Option</a></li>
<li><a href="#WithEnableCHUNKING">func WithEnableCHUNKING(enableCHUNKING bool) Option</a></li>
<li><a href="#WithEnableDSN">func WithEnableDSN(enableDSN bool) Option</a></li>
<li><a href="#WithEnableREQUIRETLS">func WithEnableREQUIRETLS(enableREQUIRETLS bool) Option</a></li>
<li><a href="#WithEnableSMTPUTF8">func WithEnableSMTPUTF8(enableSMTPUTF8 bool) Option</a></li>
<li><a href="#WithEnableXOORG">func WithEnableXOORG(enableXOORG bool) Option</a></li>
<li><a href="#WithEnforceAuthentication">func WithEnforceAuthentication(enforceAuthentication bool) Option</a></li>
<li><a href="#WithEnforceSecureConnection">func WithEnforceSecureConnection(enforceSecureConnection bool) Option</a></li>
<li><a href="#WithHostname">func WithHostname(hostname string) Option</a></li>
<li><a href="#WithImplicitTLS">func WithImplicitTLS(implicitTLS bool) Option</a></li>
<li><a href="#WithLogger">func WithLogger(logger *slog.Logger) Option</a></li>
<li><a href="#WithMaxLineLength">func WithMaxLineLength(maxLineLength int) Option</a></li>
<li><a href="#WithMaxMessageBytes">func WithMaxMessageBytes(maxMessageBytes int64) Option</a></li>
<li><a href="#WithMaxRecipients">func WithMaxRecipients(maxRecipients int) Option</a></li>
<li><a href="#WithNetwork">func WithNetwork(network string) Option</a></li>
<li><a href="#WithReadTimeout">func WithReadTimeout(readTimeout time.Duration) Option</a></li>
<li><a href="#WithReaderSize">func WithReaderSize(readerSize int) Option</a></li>
<li><a href="#WithTLSConfig">func WithTLSConfig(tlsConfig *tls.Config) Option</a></li>
<li><a href="#WithWriteTimeout">func WithWriteTimeout(writeTimeout time.Duration) Option</a></li>
<li><a href="#WithWriterSize">func WithWriterSize(writerSize int) Option</a></li>
</ul></li>
<li><a href="#Server">type Server</a>

<ul>
<li><a href="#New">func New(opts &hellip;Option) *Server</a></li>
<li><a href="#Server.Backend">func (s *Server) Backend() Backend</a></li>
<li><a href="#Server.Close">func (s *Server) Close() error</a></li>
<li><a href="#Server.Listen">func (s *Server) Listen() (net.Listener, error)</a></li>
<li><a href="#Server.ListenAndServe">func (s *Server) ListenAndServe(ctx context.Context) error</a></li>
<li><a href="#Server.Serve">func (s *Server) Serve(ctx context.Context, l net.Listener) error</a></li>
<li><a href="#Server.Shutdown">func (s *Server) Shutdown(ctx context.Context) error</a></li>
</ul></li>
<li><a href="#Session">type Session</a></li>
</ul>

<h2>Variables</h2>

<p><a name="ErrServerClosed"></a>ErrServerClosed occurs if a server is already closed.</p>

<pre><code class="language-go">var ErrServerClosed = errors.New(&quot;smtp: server already closed&quot;)
</code></pre>

<p><a name="Backend"></a></p>

<h2>type Backend</h2>

<p>Backend is a SMTP server backend.</p>

<pre><code class="language-go">type Backend interface {
    NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)
}
</code></pre>

<p><a name="BackendFunc"></a></p>

<h2>type BackendFunc</h2>

<p>BackendFunc is an adapter to allow the use of an ordinary function as a Backend.</p>

<pre><code class="language-go">type BackendFunc func(ctx context.Context, c *Conn) (context.Context, Session, error)
</code></pre>

<p><a name="BackendFunc.NewSession"></a></p>

<h3>func (BackendFunc) NewSession</h3>

<pre><code class="language-go">func (f BackendFunc) NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)
</code></pre>

<p>NewSession calls f(c). The returning context is used in the session.</p>

<p><a name="Conn"></a></p>

<h2>type Conn</h2>

<p>Conn is a connection inside a smtp server.</p>

<pre><code class="language-go">type Conn struct {
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="Conn.Close"></a></p>

<h3>func (*Conn) Close</h3>

<pre><code class="language-go">func (c *Conn) Close(err error)
</code></pre>

<p>Close closes the connection.</p>

<p><a name="Conn.Conn"></a></p>

<h3>func (*Conn) Conn</h3>

<pre><code class="language-go">func (c *Conn) Conn() net.Conn
</code></pre>

<p>Conn returns the connection.</p>

<p><a name="Conn.Hostname"></a></p>

<h3>func (*Conn) Hostname</h3>

<pre><code class="language-go">func (c *Conn) Hostname() string
</code></pre>

<p>Hostname returns the name of the connected client.</p>

<p><a name="Conn.IsTLS"></a></p>

<h3>func (*Conn) IsTLS</h3>

<pre><code class="language-go">func (c *Conn) IsTLS() bool
</code></pre>

<p>IsTLS returns if the connection is encrypted by tls.</p>

<p><a name="Conn.Mechanisms"></a></p>

<h3>func (*Conn) Mechanisms</h3>

<pre><code class="language-go">func (c *Conn) Mechanisms() []string
</code></pre>

<p>Mechanisms returns the allowed auth mechanism for this connection.</p>

<p><a name="Conn.Server"></a></p>

<h3>func (*Conn) Server</h3>

<pre><code class="language-go">func (c *Conn) Server() *Server
</code></pre>

<p>Server returns the server this connection comes from.</p>

<p><a name="Conn.TLSConnectionState"></a></p>

<h3>func (*Conn) TLSConnectionState</h3>

<pre><code class="language-go">func (c *Conn) TLSConnectionState() (tls.ConnectionState, bool)
</code></pre>

<p>TLSConnectionState returns the connection&rsquo;s TLS connection state. Zero values are returned if the connection doesn&rsquo;t use TLS.</p>

<p><a name="Option"></a></p>

<h2>type Option</h2>

<p>Option is an option for the server.</p>

<pre><code class="language-go">type Option func(*Server)
</code></pre>

<p><a name="WithAddr"></a></p>

<h3>func WithAddr</h3>

<pre><code class="language-go">func WithAddr(addr string) Option
</code></pre>

<p>WithAddr sets addr.</p>

<p><a name="WithBackend"></a></p>

<h3>func WithBackend</h3>

<pre><code class="language-go">func WithBackend(backend Backend) Option
</code></pre>

<p>WithBackend sets the backend.</p>

<p><a name="WithEnableBINARYMIME"></a></p>

<h3>func WithEnableBINARYMIME</h3>

<pre><code class="language-go">func WithEnableBINARYMIME(enableBINARYMIME bool) Option
</code></pre>

<p>WithEnableBINARYMIME sets EnableBINARYMIME.</p>

<p><a name="WithEnableCHUNKING"></a></p>

<h3>func WithEnableCHUNKING</h3>

<pre><code class="language-go">func WithEnableCHUNKING(enableCHUNKING bool) Option
</code></pre>

<p>WithEnableCHUNKING sets EnableCHUNKING.</p>

<p><a name="WithEnableDSN"></a></p>

<h3>func WithEnableDSN</h3>

<pre><code class="language-go">func WithEnableDSN(enableDSN bool) Option
</code></pre>

<p>WithEnableDSN sets EnableDSN.</p>

<p><a name="WithEnableREQUIRETLS"></a></p>

<h3>func WithEnableREQUIRETLS</h3>

<pre><code class="language-go">func WithEnableREQUIRETLS(enableREQUIRETLS bool) Option
</code></pre>

<p>WithEnableREQUIRETLS sets EnableREQUIRETLS.</p>

<p><a name="WithEnableSMTPUTF8"></a></p>

<h3>func WithEnableSMTPUTF8</h3>

<pre><code class="language-go">func WithEnableSMTPUTF8(enableSMTPUTF8 bool) Option
</code></pre>

<p>WithEnableSMTPUTF8 sets EnableSMTPUTF8.</p>

<p><a name="WithEnableXOORG"></a></p>

<h3>func WithEnableXOORG</h3>

<pre><code class="language-go">func WithEnableXOORG(enableXOORG bool) Option
</code></pre>

<p>WithEnableXOORG enables xoorg.</p>

<p><a name="WithEnforceAuthentication"></a></p>

<h3>func WithEnforceAuthentication</h3>

<pre><code class="language-go">func WithEnforceAuthentication(enforceAuthentication bool) Option
</code></pre>

<p>WithEnforceAuthentication enforces authentication before mail usage.</p>

<p><a name="WithEnforceSecureConnection"></a></p>

<h3>func WithEnforceSecureConnection</h3>

<pre><code class="language-go">func WithEnforceSecureConnection(enforceSecureConnection bool) Option
</code></pre>

<p>WithEnforceSecureConnection enforces implicit TLS or STARTTLS.</p>

<p><a name="WithHostname"></a></p>

<h3>func WithHostname</h3>

<pre><code class="language-go">func WithHostname(hostname string) Option
</code></pre>

<p>WithHostname sets the domain.</p>

<p><a name="WithImplicitTLS"></a></p>

<h3>func WithImplicitTLS</h3>

<pre><code class="language-go">func WithImplicitTLS(implicitTLS bool) Option
</code></pre>

<p>WithImplicitTLS sets implicitTLS.</p>

<p><a name="WithLogger"></a></p>

<h3>func WithLogger</h3>

<pre><code class="language-go">func WithLogger(logger *slog.Logger) Option
</code></pre>

<p>WithLogger sets the backend.</p>

<p><a name="WithMaxLineLength"></a></p>

<h3>func WithMaxLineLength</h3>

<pre><code class="language-go">func WithMaxLineLength(maxLineLength int) Option
</code></pre>

<p>WithMaxLineLength sets the max length per line.</p>

<p><a name="WithMaxMessageBytes"></a></p>

<h3>func WithMaxMessageBytes</h3>

<pre><code class="language-go">func WithMaxMessageBytes(maxMessageBytes int64) Option
</code></pre>

<p>WithMaxMessageBytes sets the max message size.</p>

<p><a name="WithMaxRecipients"></a></p>

<h3>func WithMaxRecipients</h3>

<pre><code class="language-go">func WithMaxRecipients(maxRecipients int) Option
</code></pre>

<p>WithMaxRecipients sets the max recipients per mail.</p>

<p><a name="WithNetwork"></a></p>

<h3>func WithNetwork</h3>

<pre><code class="language-go">func WithNetwork(network string) Option
</code></pre>

<p>WithNetwork sets the network.</p>

<p><a name="WithReadTimeout"></a></p>

<h3>func WithReadTimeout</h3>

<pre><code class="language-go">func WithReadTimeout(readTimeout time.Duration) Option
</code></pre>

<p>WithReadTimeout sets the read timeout.</p>

<p><a name="WithReaderSize"></a></p>

<h3>func WithReaderSize</h3>

<pre><code class="language-go">func WithReaderSize(readerSize int) Option
</code></pre>

<p>WithReaderSize sets ReaderSize.</p>

<p><a name="WithTLSConfig"></a></p>

<h3>func WithTLSConfig</h3>

<pre><code class="language-go">func WithTLSConfig(tlsConfig *tls.Config) Option
</code></pre>

<p>WithTLSConfig sets certificate.</p>

<p><a name="WithWriteTimeout"></a></p>

<h3>func WithWriteTimeout</h3>

<pre><code class="language-go">func WithWriteTimeout(writeTimeout time.Duration) Option
</code></pre>

<p>WithWriteTimeout sets the write timeout.</p>

<p><a name="WithWriterSize"></a></p>

<h3>func WithWriterSize</h3>

<pre><code class="language-go">func WithWriterSize(writerSize int) Option
</code></pre>

<p>WithWriterSize sets WriterSize.</p>

<p><a name="Server"></a></p>

<h2>type Server</h2>

<p>Server implements a SMTP server.</p>

<pre><code class="language-go">type Server struct {
    // contains filtered or unexported fields
}
</code></pre>

<details><summary>Example</summary>
<p>

ExampleServer runs an example SMTP server.

It can be tested manually with e.g. netcat:

```
> netcat -C localhost 1025
EHLO localhost
AUTH PLAIN
AHVzZXJuYW1lAHBhc3N3b3Jk
MAIL FROM:<root@nsa.gov>
RCPT TO:<root@gchq.gov.uk>
DATA
Hey <3
.
```

```go
package main

import (
	"context"
	"crypto/tls"
	"errors"
	"io"
	"log"
	"log/slog"
	"time"

	"github.com/uponusolutions/go-sasl"
	"github.com/uponusolutions/go-smtp"
	"github.com/uponusolutions/go-smtp/server"
)

// The Backend implements SMTP server methods.
type Backend struct{}

// NewSession is called after client greeting (EHLO, HELO).
func (*Backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error) {
	return ctx, &Session{}, nil
}

// A Session is returned after successful login.
type Session struct {
	auth bool
}

// Logger returns nil.
func (*Session) Logger(_ context.Context) *slog.Logger {
	return nil
}

// AuthMechanisms returns a slice of available auth mechanisms; only PLAIN is
// supported in this example.
func (*Session) AuthMechanisms(_ context.Context) []string {
	return []string{sasl.Plain}
}

// Auth is the handler for supported authenticators.
func (s *Session) Auth(_ context.Context, _ string) (sasl.Server, error) {
	return sasl.NewPlainServer(func(_, username, password string) error {
		if username != "username" || password != "password" {
			return errors.New("Invalid username or password")
		}
		s.auth = true
		return nil
	}), nil
}

func (s *Session) Mail(_ context.Context, from string, _ *smtp.MailOptions) error {
	if !s.auth {
		return smtp.ErrAuthRequired
	}
	log.Println("Mail from:", from)
	return nil
}

func (*Session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error {
	return nil
}

func (s *Session) Rcpt(_ context.Context, to string, _ *smtp.RcptOptions) error {
	if !s.auth {
		return smtp.ErrAuthRequired
	}
	log.Println("Rcpt to:", to)
	return nil
}

func (*Session) STARTTLS(_ context.Context, tls *tls.Config) (*tls.Config, error) {
	return tls, nil
}

func (s *Session) Data(_ context.Context, r func() io.Reader) (string, error) {
	if !s.auth {
		return "", smtp.ErrAuthRequired
	}

	b, err := io.ReadAll(r())
	if err != nil {
		return "", err
	}
	log.Println("Data:", string(b))
	return "", nil
}

func (*Session) Reset(ctx context.Context, _ bool) (context.Context, error) {
	return ctx, nil
}

func (*Session) Close(_ context.Context, _ error) {
}

// ExampleServer runs an example SMTP server.
//
// It can be tested manually with e.g. netcat:
//
//	> netcat -C localhost 1025
//	EHLO localhost
//	AUTH PLAIN
//	AHVzZXJuYW1lAHBhc3N3b3Jk
//	MAIL FROM:<root@nsa.gov>
//	RCPT TO:<root@gchq.gov.uk>
//	DATA
//	Hey <3
//	.
func main() {
	be := &Backend{}
	addr := "localhost:1025"

	s := server.New(
		server.WithBackend(be),
		server.WithAddr(addr),
		server.WithHostname("localhost"),
		server.WithWriteTimeout(10*time.Second),
		server.WithReadTimeout(10*time.Second),
		server.WithMaxMessageBytes(1024*1024),
		server.WithMaxRecipients(50),
	)

	log.Println("Starting server at", addr)
	if err := s.ListenAndServe(context.Background()); err != nil {
		log.Fatal(err)
	}
}
```

</p>
</details>

<p><a name="New"></a></p>

<h3>func New</h3>

<pre><code class="language-go">func New(opts ...Option) *Server
</code></pre>

<p>New creates a new SMTP server.</p>

<p><a name="Server.Backend"></a></p>

<h3>func (*Server) Backend</h3>

<pre><code class="language-go">func (s *Server) Backend() Backend
</code></pre>

<p>Backend returns the servers Backend.</p>

<p><a name="Server.Close"></a></p>

<h3>func (*Server) Close</h3>

<pre><code class="language-go">func (s *Server) Close() error
</code></pre>

<p>Close immediately closes all active listeners and connections.</p>

<p>Close returns any error returned from closing the server&rsquo;s underlying listener(s).</p>

<p><a name="Server.Listen"></a></p>

<h3>func (*Server) Listen</h3>

<pre><code class="language-go">func (s *Server) Listen() (net.Listener, error)
</code></pre>

<p>Listen listens on the network address s.Addr to handle requests on incoming connections.</p>

<p>If s.Addr is blank and LMTP is disabled, &ldquo;:smtp&rdquo; is used.</p>

<p><a name="Server.ListenAndServe"></a></p>

<h3>func (*Server) ListenAndServe</h3>

<pre><code class="language-go">func (s *Server) ListenAndServe(ctx context.Context) error
</code></pre>

<p>ListenAndServe listens on the network address s.Addr and then calls Serve to handle requests on incoming connections.</p>

<p>If s.Addr is blank and LMTP is disabled, &ldquo;:smtp&rdquo; is used.</p>

<p><a name="Server.Serve"></a></p>

<h3>func (*Server) Serve</h3>

<pre><code class="language-go">func (s *Server) Serve(ctx context.Context, l net.Listener) error
</code></pre>

<p>Serve accepts incoming connections on the Listener l.</p>

<p><a name="Server.Shutdown"></a></p>

<h3>func (*Server) Shutdown</h3>

<pre><code class="language-go">func (s *Server) Shutdown(ctx context.Context) error
</code></pre>

<p>Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context&rsquo;s error, otherwise it returns any error returned from closing the Server&rsquo;s underlying Listener(s).</p>

<p><a name="Session"></a></p>

<h2>type Session</h2>

<p>Session is used by servers to respond to an SMTP client.</p>

<p>The methods are called when the remote client issues the matching command.</p>

<pre><code class="language-go">type Session interface {
    // Discard currently processed message.
    // The returning context replaces the context used in the current session.
    // Upgrade is true when the reset is called after a tls upgrade.
    Reset(ctx context.Context, upgrade bool) (context.Context, error)

    // Free all resources associated with session.
    // Error is set if an error occurred during session or connection.
    // Close is always called after the session is done.
    Close(ctx context.Context, err error)

    // Returns logger to use when an error occurs inside a session.
    // If no logger is returned the default *slog.Logger is used.
    Logger(ctx context.Context) *slog.Logger

    // Set return path for currently processed message.
    Mail(ctx context.Context, from string, opts *smtp.MailOptions) error

    // Add recipient for currently processed message.
    Rcpt(ctx context.Context, to string, opts *smtp.RcptOptions) error

    // Verify checks the validity of an email address on the server.
    // If error is nil then smtp code 252 is send
    // if error is smtp status then the smtp status is send
    // else internal server error is returned and connection is closed
    Verify(ctx context.Context, addr string, opts *smtp.VrfyOptions) error

    // Set currently processed message contents and send it.
    // If r is called then the data must be consumed completely before returning.
    // The queuedid must not be unique.
    Data(ctx context.Context, r func() io.Reader) (queueid string, err error)

    // AuthMechanisms returns valid auth mechanism.
    // Nil or an empty list means no authentication mechanism is allowed.
    AuthMechanisms(ctx context.Context) []string

    // Auth returns a matching sasl server for the given mech.
    Auth(ctx context.Context, mech string) (sasl.Server, error)

    // STARTTLS returns a valid *tls.Config.
    // Is called with the default tls config and the returned tls config is used in the tls upgrade.
    // If the tls.Config is nil or an error is returned, the tls upgrade is aborted and the connection closed.
    // The *tls.Config received must not be changed.
    STARTTLS(ctx context.Context, tls *tls.Config) (*tls.Config, error)
}
</code></pre>

<h1>tester</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/tester&quot;
</code></pre>

<p>Package smtptester implements a simple SMTP server for testing. All received mails are saved in a sync.Map with a key:</p>

<pre><code>From+Recipient1+Recipient2
</code></pre>

<p>Mails to the same sender and recipients will overwrite a previous received mail, when the recipients slice has the same order as in the mail received before.</p>

<h2>Index</h2>

<ul>
<li><a href="#GenX509KeyPair">func GenX509KeyPair(domain string) (tls.Certificate, error)</a></li>
<li><a href="#LookupKey">func LookupKey(f string, r []string) string</a></li>
<li><a href="#ReaderCompareTest">func ReaderCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Reader) ([]byte, error), actual func(io.Reader) ([]byte, error))</a></li>
<li><a href="#Standard">func Standard() *server.Server</a></li>
<li><a href="#StandardWithAddress">func StandardWithAddress(addr string) *server.Server</a></li>
<li><a href="#WriterCompareTest">func WriterCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Writer) io.WriteCloser, actual func(io.Writer) io.WriteCloser)</a></li>
<li><a href="#Backend">type Backend</a>

<ul>
<li><a href="#GetBackend">func GetBackend(s *server.Server) *Backend</a></li>
<li><a href="#NewBackend">func NewBackend() *Backend</a></li>
<li><a href="#Backend.Add">func (b *Backend) Add(m *Mail)</a></li>
<li><a href="#Backend.Load">func (b *Backend) Load(from string, recipients []string) (*Mail, bool)</a></li>
<li><a href="#Backend.NewSession">func (b *Backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error)</a></li>
</ul></li>
<li><a href="#FakeConn">type FakeConn</a>

<ul>
<li><a href="#NewFakeConn">func NewFakeConn(in string, out *bytes.Buffer) *FakeConn</a></li>
<li><a href="#NewFakeConnStream">func NewFakeConnStream(in io.Reader, out *bytes.Buffer) *FakeConn</a></li>
<li><a href="#FakeConn.Close">func (FakeConn) Close() error</a></li>
<li><a href="#FakeConn.LocalAddr">func (FakeConn) LocalAddr() net.Addr</a></li>
<li><a href="#FakeConn.RemoteAddr">func (f FakeConn) RemoteAddr() net.Addr</a></li>
<li><a href="#FakeConn.SetDeadline">func (FakeConn) SetDeadline(time.Time) error</a></li>
<li><a href="#FakeConn.SetReadDeadline">func (FakeConn) SetReadDeadline(time.Time) error</a></li>
<li><a href="#FakeConn.SetWriteDeadline">func (FakeConn) SetWriteDeadline(time.Time) error</a></li>
</ul></li>
<li><a href="#Mail">type Mail</a>

<ul>
<li><a href="#Mail.LookupKey">func (m *Mail) LookupKey() string</a></li>
</ul></li>
<li><a href="#Session">type Session</a>

<ul>
<li><a href="#Session.Auth">func (Session) Auth(_ context.Context, _ string) (sasl.Server, error)</a></li>
<li><a href="#Session.AuthMechanisms">func (Session) AuthMechanisms(_ context.Context) []string</a></li>
<li><a href="#Session.Close">func (s *Session) Close(_ context.Context, _ error)</a></li>
<li><a href="#Session.Data">func (s *Session) Data(_ context.Context, r func() io.Reader) (string, error)</a></li>
<li><a href="#Session.Logger">func (Session) Logger(_ context.Context) *slog.Logger</a></li>
<li><a href="#Session.Mail">func (s *Session) Mail(_ context.Context, from string, _ *smtp.MailOptions) error</a></li>
<li><a href="#Session.Rcpt">func (s *Session) Rcpt(_ context.Context, to string, _ *smtp.RcptOptions) error</a></li>
<li><a href="#Session.Reset">func (s *Session) Reset(ctx context.Context, _ bool) (context.Context, error)</a></li>
<li><a href="#Session.STARTTLS">func (Session) STARTTLS(_ context.Context, config *tls.Config) (*tls.Config, error)</a></li>
<li><a href="#Session.Verify">func (Session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error</a></li>
</ul></li>
</ul>

<p><a name="GenX509KeyPair"></a></p>

<h2>func GenX509KeyPair</h2>

<pre><code class="language-go">func GenX509KeyPair(domain string) (tls.Certificate, error)
</code></pre>

<p>GenX509KeyPair generates a self signed smtp server certificate with the given domain.</p>

<p><a name="LookupKey"></a></p>

<h2>func LookupKey</h2>

<pre><code class="language-go">func LookupKey(f string, r []string) string
</code></pre>

<p>LookupKey returns a key of the format:</p>

<pre><code>m.From+m.Recipient_1+m.Recipient_2...
</code></pre>

<p><a name="ReaderCompareTest"></a></p>

<h2>func ReaderCompareTest</h2>

<pre><code class="language-go">func ReaderCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Reader) ([]byte, error), actual func(io.Reader) ([]byte, error))
</code></pre>

<p>ReaderCompareTest reads all files out of fs[path] and compares the result of the expected func against the actual func. To simulate differences of Read calls with different sizes it slices the files in increasing sizes up to 4048.</p>

<p><a name="Standard"></a></p>

<h2>func Standard</h2>

<pre><code class="language-go">func Standard() *server.Server
</code></pre>

<p>Standard returns a standard SMTP server listening on a random Port.</p>

<p><a name="StandardWithAddress"></a></p>

<h2>func StandardWithAddress</h2>

<pre><code class="language-go">func StandardWithAddress(addr string) *server.Server
</code></pre>

<p>StandardWithAddress with address returns a standard SMTP server listenting on addr.</p>

<p><a name="WriterCompareTest"></a></p>

<h2>func WriterCompareTest</h2>

<pre><code class="language-go">func WriterCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Writer) io.WriteCloser, actual func(io.Writer) io.WriteCloser)
</code></pre>

<p>WriterCompareTest reads all files out of fs[path] and compares the expected func against the actual func. To simulate differences of Write calls of different sizes it slices the files in increasing sizes up to 4048.</p>

<p><a name="Backend"></a></p>

<h2>type Backend</h2>

<p>Backend is the backend for out test server. It contains a sync.Map with all mails received.</p>

<pre><code class="language-go">type Backend struct {
    Mails sync.Map
}
</code></pre>

<p><a name="GetBackend"></a></p>

<h3>func GetBackend</h3>

<pre><code class="language-go">func GetBackend(s *server.Server) *Backend
</code></pre>

<p>GetBackend returns the concrete type *Backend from SMTP server.</p>

<p><a name="NewBackend"></a></p>

<h3>func NewBackend</h3>

<pre><code class="language-go">func NewBackend() *Backend
</code></pre>

<p>NewBackend returns a new Backend with an empty (not nil) Mails map.</p>

<p><a name="Backend.Add"></a></p>

<h3>func (*Backend) Add</h3>

<pre><code class="language-go">func (b *Backend) Add(m *Mail)
</code></pre>

<p>Add adds mail to backends map.</p>

<p><a name="Backend.Load"></a></p>

<h3>func (*Backend) Load</h3>

<pre><code class="language-go">func (b *Backend) Load(from string, recipients []string) (*Mail, bool)
</code></pre>

<p>Load loads mail from &lsquo;from&rsquo; to recipients &lsquo;recipients&rsquo;. The ok result indicates whether value was found in the map.</p>

<p><a name="Backend.NewSession"></a></p>

<h3>func (*Backend) NewSession</h3>

<pre><code class="language-go">func (b *Backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error)
</code></pre>

<p>NewSession returns a new Session.</p>

<p><a name="FakeConn"></a></p>

<h2>type FakeConn</h2>

<p>FakeConn fakes a conn for testing.</p>

<pre><code class="language-go">type FakeConn struct {
    io.ReadWriter
    RemoteAddrReturn net.Addr
}
</code></pre>

<p><a name="NewFakeConn"></a></p>

<h3>func NewFakeConn</h3>

<pre><code class="language-go">func NewFakeConn(in string, out *bytes.Buffer) *FakeConn
</code></pre>

<p>NewFakeConn creates a new FakeConn with a string as a input.</p>

<p><a name="NewFakeConnStream"></a></p>

<h3>func NewFakeConnStream</h3>

<pre><code class="language-go">func NewFakeConnStream(in io.Reader, out *bytes.Buffer) *FakeConn
</code></pre>

<p>NewFakeConnStream creates a new FakeConn with a stream as a input.</p>

<p><a name="FakeConn.Close"></a></p>

<h3>func (FakeConn) Close</h3>

<pre><code class="language-go">func (FakeConn) Close() error
</code></pre>

<p>Close always returns nil.</p>

<p><a name="FakeConn.LocalAddr"></a></p>

<h3>func (FakeConn) LocalAddr</h3>

<pre><code class="language-go">func (FakeConn) LocalAddr() net.Addr
</code></pre>

<p>LocalAddr always returns nil.</p>

<p><a name="FakeConn.RemoteAddr"></a></p>

<h3>func (FakeConn) RemoteAddr</h3>

<pre><code class="language-go">func (f FakeConn) RemoteAddr() net.Addr
</code></pre>

<p>RemoteAddr always returns RemoteAddrReturn.</p>

<p><a name="FakeConn.SetDeadline"></a></p>

<h3>func (FakeConn) SetDeadline</h3>

<pre><code class="language-go">func (FakeConn) SetDeadline(time.Time) error
</code></pre>

<p>SetDeadline always returns nil and does nothing.</p>

<p><a name="FakeConn.SetReadDeadline"></a></p>

<h3>func (FakeConn) SetReadDeadline</h3>

<pre><code class="language-go">func (FakeConn) SetReadDeadline(time.Time) error
</code></pre>

<p>SetReadDeadline always returns nil and does nothing.</p>

<p><a name="FakeConn.SetWriteDeadline"></a></p>

<h3>func (FakeConn) SetWriteDeadline</h3>

<pre><code class="language-go">func (FakeConn) SetWriteDeadline(time.Time) error
</code></pre>

<p>SetWriteDeadline always returns nil and does nothing.</p>

<p><a name="Mail"></a></p>

<h2>type Mail</h2>

<p>Mail is one mail received by SMTP server.</p>

<pre><code class="language-go">type Mail struct {
    From       string
    Recipients []string
    Data       []byte
}
</code></pre>

<p><a name="Mail.LookupKey"></a></p>

<h3>func (*Mail) LookupKey</h3>

<pre><code class="language-go">func (m *Mail) LookupKey() string
</code></pre>

<p>LookupKey call LookupKey for current mail.</p>

<p><a name="Session"></a></p>

<h2>type Session</h2>

<p>A Session is returned after successful login.</p>

<pre><code class="language-go">type Session struct {
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="Session.Auth"></a></p>

<h3>func (Session) Auth</h3>

<pre><code class="language-go">func (Session) Auth(_ context.Context, _ string) (sasl.Server, error)
</code></pre>

<p>Auth implements the Auth interface.</p>

<p><a name="Session.AuthMechanisms"></a></p>

<h3>func (Session) AuthMechanisms</h3>

<pre><code class="language-go">func (Session) AuthMechanisms(_ context.Context) []string
</code></pre>

<p>AuthMechanisms implements the AuthMechanisms interface.</p>

<p><a name="Session.Close"></a></p>

<h3>func (*Session) Close</h3>

<pre><code class="language-go">func (s *Session) Close(_ context.Context, _ error)
</code></pre>

<p>Close implements the Close interface.</p>

<p><a name="Session.Data"></a></p>

<h3>func (*Session) Data</h3>

<pre><code class="language-go">func (s *Session) Data(_ context.Context, r func() io.Reader) (string, error)
</code></pre>

<p>Data implements the Data interface.</p>

<p><a name="Session.Logger"></a></p>

<h3>func (Session) Logger</h3>

<pre><code class="language-go">func (Session) Logger(_ context.Context) *slog.Logger
</code></pre>

<p>Logger implements the Logger interface.</p>

<p><a name="Session.Mail"></a></p>

<h3>func (*Session) Mail</h3>

<pre><code class="language-go">func (s *Session) Mail(_ context.Context, from string, _ *smtp.MailOptions) error
</code></pre>

<p>Mail implements the Mail interface.</p>

<p><a name="Session.Rcpt"></a></p>

<h3>func (*Session) Rcpt</h3>

<pre><code class="language-go">func (s *Session) Rcpt(_ context.Context, to string, _ *smtp.RcptOptions) error
</code></pre>

<p>Rcpt implements the Rcpt interface.</p>

<p><a name="Session.Reset"></a></p>

<h3>func (*Session) Reset</h3>

<pre><code class="language-go">func (s *Session) Reset(ctx context.Context, _ bool) (context.Context, error)
</code></pre>

<p>Reset implements Reset interface.</p>

<p><a name="Session.STARTTLS"></a></p>

<h3>func (Session) STARTTLS</h3>

<pre><code class="language-go">func (Session) STARTTLS(_ context.Context, config *tls.Config) (*tls.Config, error)
</code></pre>

<p>STARTTLS implements the STARTTLS interface.</p>

<p><a name="Session.Verify"></a></p>

<h3>func (Session) Verify</h3>

<pre><code class="language-go">func (Session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error
</code></pre>

<p>Verify implements the Verify interface.</p>

<h1>faker</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/examples/faker&quot;
</code></pre>

<h2>Index</h2>

<h1>benchmark</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/internal/benchmark&quot;
</code></pre>

<h2>Index</h2>

<h1>limit</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/internal/limit&quot;
</code></pre>

<h2>Index</h2>

<ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#Ratelimit">type Ratelimit</a>

<ul>
<li><a href="#New">func New(config *RatelimitConfig) *Ratelimit</a></li>
<li><a href="#Ratelimit.Take">func (c *Ratelimit) Take() error</a></li>
</ul></li>
<li><a href="#RatelimitConfig">type RatelimitConfig</a></li>
</ul>

<h2>Variables</h2>

<p><a name="ErrRatelimit"></a>ErrRatelimit is returned if limit reached and strict mode is enabled.</p>

<pre><code class="language-go">var ErrRatelimit = errors.New(&quot;rate limit occurred&quot;)
</code></pre>

<p><a name="Ratelimit"></a></p>

<h2>type Ratelimit</h2>

<p>Ratelimit is used e.g. to limit the calls to a function.</p>

<pre><code class="language-go">type Ratelimit struct {
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="New"></a></p>

<h3>func New</h3>

<pre><code class="language-go">func New(config *RatelimitConfig) *Ratelimit
</code></pre>

<p>New creates a new rate limit.</p>

<p><a name="Ratelimit.Take"></a></p>

<h3>func (*Ratelimit) Take</h3>

<pre><code class="language-go">func (c *Ratelimit) Take() error
</code></pre>

<p>Take returns when it is allowed to do something again.</p>

<p><a name="RatelimitConfig"></a></p>

<h2>type RatelimitConfig</h2>

<p>RatelimitConfig configures a rate limit.</p>

<pre><code class="language-go">type RatelimitConfig struct {
    Rate     int
    Duration time.Duration
    Strict   bool
}
</code></pre>

<h1>parse</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/internal/parse&quot;
</code></pre>

<h2>Index</h2>

<ul>
<li><a href="#Args">func Args(s string) (map[string]string, error)</a></li>
<li><a href="#Cmd">func Cmd(line string) (cmd string, arg string, err error)</a></li>
<li><a href="#CutPrefixFold">func CutPrefixFold(s, prefix string) (string, bool)</a></li>
<li><a href="#HelloArgument">func HelloArgument(arg string) (string, error)</a></li>
<li><a href="#Parser">type Parser</a>

<ul>
<li><a href="#Parser.Mailbox">func (p *Parser) Mailbox() (string, error)</a></li>
<li><a href="#Parser.Path">func (p *Parser) Path() (string, error)</a></li>
<li><a href="#Parser.ReversePath">func (p *Parser) ReversePath() (string, error)</a></li>
</ul></li>
</ul>

<p><a name="Args"></a></p>

<h2>func Args</h2>

<pre><code class="language-go">func Args(s string) (map[string]string, error)
</code></pre>

<p>Args takes the arguments proceeding a command and files them into a map[string]string after uppercasing each key. Sample arg string:</p>

<pre><code>&quot; BODY=8BITMIME SIZE=1024 SMTPUTF8&quot;
</code></pre>

<p>The leading space is mandatory.</p>

<p><a name="Cmd"></a></p>

<h2>func Cmd</h2>

<pre><code class="language-go">func Cmd(line string) (cmd string, arg string, err error)
</code></pre>

<p>Cmd parses a line and returns the command, argument or an error.</p>

<p><a name="CutPrefixFold"></a></p>

<h2>func CutPrefixFold</h2>

<pre><code class="language-go">func CutPrefixFold(s, prefix string) (string, bool)
</code></pre>

<p>CutPrefixFold is a version of strings.CutPrefix which is case-insensitive.</p>

<p><a name="HelloArgument"></a></p>

<h2>func HelloArgument</h2>

<pre><code class="language-go">func HelloArgument(arg string) (string, error)
</code></pre>

<p>HelloArgument parses helo argument</p>

<p><a name="Parser"></a></p>

<h2>type Parser</h2>

<p>Parser parses command arguments defined in RFC 5321 section 4.1.2.</p>

<pre><code class="language-go">type Parser struct {
    S string
}
</code></pre>

<p><a name="Parser.Mailbox"></a></p>

<h3>func (*Parser) Mailbox</h3>

<pre><code class="language-go">func (p *Parser) Mailbox() (string, error)
</code></pre>

<p>Mailbox parses a mailbox.</p>

<p><a name="Parser.Path"></a></p>

<h3>func (*Parser) Path</h3>

<pre><code class="language-go">func (p *Parser) Path() (string, error)
</code></pre>

<p>Path parses a recipient.</p>

<p><a name="Parser.ReversePath"></a></p>

<h3>func (*Parser) ReversePath</h3>

<pre><code class="language-go">func (p *Parser) ReversePath() (string, error)
</code></pre>

<p>ReversePath parses a recipient.</p>

<h1>textsmtp</h1>

<pre><code class="language-go">import &quot;github.com/uponusolutions/go-smtp/internal/textsmtp&quot;
</code></pre>

<h2>Index</h2>

<ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#CheckNotifySet">func CheckNotifySet(values []smtp.DSNNotify) error</a></li>
<li><a href="#IsPrintableASCII">func IsPrintableASCII(val string) bool</a></li>
<li><a href="#NewDotReader">func NewDotReader(reader *bufio.Reader, maxMessageBytes int64) io.Reader</a></li>
<li><a href="#NewDotWriter">func NewDotWriter(writer *bufio.Writer) io.WriteCloser</a></li>
<li><a href="#Textproto">type Textproto</a>

<ul>
<li><a href="#NewTextproto">func NewTextproto(conn io.ReadWriteCloser, readerSize int, writerSize int, maxLineLength int) *Textproto</a></li>
<li><a href="#Textproto.Close">func (t *Textproto) Close() error</a></li>
<li><a href="#Textproto.Cmd">func (t *Textproto) Cmd(format string, args &hellip;any) (id uint, err error)</a></li>
<li><a href="#Textproto.PrintfLine">func (t *Textproto) PrintfLine(format string, args &hellip;any) error</a></li>
<li><a href="#Textproto.PrintfLineAndFlush">func (t *Textproto) PrintfLineAndFlush(format string, args &hellip;any) error</a></li>
<li><a href="#Textproto.ReadCodeLine">func (t *Textproto) ReadCodeLine(expectCode int) (int, string, error)</a></li>
<li><a href="#Textproto.ReadLine">func (t *Textproto) ReadLine() (string, error)</a></li>
<li><a href="#Textproto.ReadResponse">func (t *Textproto) ReadResponse(expectCode int) (code int, message string, err error)</a></li>
<li><a href="#Textproto.Replace">func (t *Textproto) Replace(conn io.ReadWriteCloser)</a></li>
</ul></li>
</ul>

<h2>Variables</h2>

<p><a name="ErrTooLongLine"></a>ErrTooLongLine occurs if the smtp line is too long.</p>

<pre><code class="language-go">var ErrTooLongLine = errors.New(&quot;smtp: too long a line in input stream&quot;)
</code></pre>

<p><a name="CheckNotifySet"></a></p>

<h2>func CheckNotifySet</h2>

<pre><code class="language-go">func CheckNotifySet(values []smtp.DSNNotify) error
</code></pre>

<p>CheckNotifySet checks if a DSNNotify array isn&rsquo;t malformed.</p>

<p><a name="IsPrintableASCII"></a></p>

<h2>func IsPrintableASCII</h2>

<pre><code class="language-go">func IsPrintableASCII(val string) bool
</code></pre>

<p>IsPrintableASCII checks if string contains only printable ascii.</p>

<p><a name="NewDotReader"></a></p>

<h2>func NewDotReader</h2>

<pre><code class="language-go">func NewDotReader(reader *bufio.Reader, maxMessageBytes int64) io.Reader
</code></pre>

<p>NewDotReader creates a new dot reader.</p>

<p><a name="NewDotWriter"></a></p>

<h2>func NewDotWriter</h2>

<pre><code class="language-go">func NewDotWriter(writer *bufio.Writer) io.WriteCloser
</code></pre>

<p>NewDotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \n into \r\n, and adding the final .\r\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.</p>

<p>See the documentation for Reader&rsquo;s DotReader method for details about dot-encoding.</p>

<p><a name="Textproto"></a></p>

<h2>type Textproto</h2>

<p>Textproto is used as a wrapper around a connection to read and write to it</p>

<pre><code class="language-go">type Textproto struct {
    R   *bufio.Reader
    W   *bufio.Writer

    textproto.Pipeline
    // contains filtered or unexported fields
}
</code></pre>

<p><a name="NewTextproto"></a></p>

<h3>func NewTextproto</h3>

<pre><code class="language-go">func NewTextproto(conn io.ReadWriteCloser, readerSize int, writerSize int, maxLineLength int) *Textproto
</code></pre>

<p>NewTextproto creates a new connection wrapper.</p>

<p><a name="Textproto.Close"></a></p>

<h3>func (*Textproto) Close</h3>

<pre><code class="language-go">func (t *Textproto) Close() error
</code></pre>

<p>Close closes the connection.</p>

<p><a name="Textproto.Cmd"></a></p>

<h3>func (*Textproto) Cmd</h3>

<pre><code class="language-go">func (t *Textproto) Cmd(format string, args ...any) (id uint, err error)
</code></pre>

<p>Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \r\n. Cmd returns the id of the command, for use with StartResponse and EndResponse.</p>

<p>For example, a client might run a HELP command that returns a dot-body by using:</p>

<pre><code>id, err := c.Cmd(&quot;HELP&quot;)
if err != nil {
	return nil, err
}

c.StartResponse(id)
defer c.EndResponse(id)

if _, _, err = c.ReadCodeLine(110); err != nil {
	return nil, err
}
text, err := c.ReadDotBytes()
if err != nil {
	return nil, err
}
return c.ReadCodeLine(250)
</code></pre>

<p><a name="Textproto.PrintfLine"></a></p>

<h3>func (*Textproto) PrintfLine</h3>

<pre><code class="language-go">func (t *Textproto) PrintfLine(format string, args ...any) error
</code></pre>

<p>PrintfLine writes the formatted output followed by \r\n.</p>

<p><a name="Textproto.PrintfLineAndFlush"></a></p>

<h3>func (*Textproto) PrintfLineAndFlush</h3>

<pre><code class="language-go">func (t *Textproto) PrintfLineAndFlush(format string, args ...any) error
</code></pre>

<p>PrintfLineAndFlush writes the formatted output followed by \r\n anf flushes.</p>

<p><a name="Textproto.ReadCodeLine"></a></p>

<h3>func (*Textproto) ReadCodeLine</h3>

<pre><code class="language-go">func (t *Textproto) ReadCodeLine(expectCode int) (int, string, error)
</code></pre>

<p>ReadCodeLine reads a code line.</p>

<p><a name="Textproto.ReadLine"></a></p>

<h3>func (*Textproto) ReadLine</h3>

<pre><code class="language-go">func (t *Textproto) ReadLine() (string, error)
</code></pre>

<p>ReadLine reads a single line from r, eliding the final \n or \r\n from the returned string.</p>

<p><a name="Textproto.ReadResponse"></a></p>

<h3>func (*Textproto) ReadResponse</h3>

<pre><code class="language-go">func (t *Textproto) ReadResponse(expectCode int) (code int, message string, err error)
</code></pre>

<p>ReadResponse reads a multi-line response of the form:</p>

<pre><code>code-message line 1
code-message line 2
...
code message line n
</code></pre>

<p>where code is a three-digit status code. The first line starts with the code and a hyphen. The response is terminated by a line that starts with the same code followed by a space. Each line in message is separated by a newline (\n).</p>

<p>See page 36 of RFC 959 (<a href="https://www.ietf.org/rfc/rfc959.txt">https://www.ietf.org/rfc/rfc959.txt</a>) for details of another form of response accepted:</p>

<pre><code>code-message line 1
message line 2
...
code message line n
</code></pre>

<p>If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &amp;Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].</p>

<p>An expectCode &lt;= 0 disables the check of the status code.</p>

<p><a name="Textproto.Replace"></a></p>

<h3>func (*Textproto) Replace</h3>

<pre><code class="language-go">func (t *Textproto) Replace(conn io.ReadWriteCloser)
</code></pre>

<p>Replace conn.</p>

<p>Generated by <a href="https://github.com/princjef/gomarkdoc">gomarkdoc</a></p>

<p><!-- gomarkdoc:embed:end --></p>
