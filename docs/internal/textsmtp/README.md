<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# textsmtp

```go
import "github.com/uponusolutions/go-smtp/internal/textsmtp"
```

## Index

- [Variables](<#variables>)
- [func CheckNotifySet\(values \[\]smtp.DSNNotify\) error](<#CheckNotifySet>)
- [func IsPrintableASCII\(val string\) bool](<#IsPrintableASCII>)
- [func NewDotReader\(reader \*bufio.Reader, maxMessageBytes int64\) io.Reader](<#NewDotReader>)
- [func NewDotWriter\(writer \*bufio.Writer\) io.WriteCloser](<#NewDotWriter>)
- [type Textproto](<#Textproto>)
  - [func NewTextproto\(conn io.ReadWriteCloser, readerSize int, writerSize int, maxLineLength int\) \*Textproto](<#NewTextproto>)
  - [func \(t \*Textproto\) Close\(\) error](<#Textproto.Close>)
  - [func \(t \*Textproto\) Cmd\(format string, args ...any\) \(id uint, err error\)](<#Textproto.Cmd>)
  - [func \(t \*Textproto\) PrintfLine\(format string, args ...any\) error](<#Textproto.PrintfLine>)
  - [func \(t \*Textproto\) PrintfLineAndFlush\(format string, args ...any\) error](<#Textproto.PrintfLineAndFlush>)
  - [func \(t \*Textproto\) ReadCodeLine\(expectCode int\) \(int, string, error\)](<#Textproto.ReadCodeLine>)
  - [func \(t \*Textproto\) ReadLine\(\) \(string, error\)](<#Textproto.ReadLine>)
  - [func \(t \*Textproto\) ReadResponse\(expectCode int\) \(code int, message string, err error\)](<#Textproto.ReadResponse>)
  - [func \(t \*Textproto\) Replace\(conn io.ReadWriteCloser\)](<#Textproto.Replace>)


## Variables

<a name="ErrTooLongLine"></a>ErrTooLongLine occurs if the smtp line is too long.

```go
var ErrTooLongLine = errors.New("smtp: too long a line in input stream")
```

<a name="CheckNotifySet"></a>
## func CheckNotifySet

```go
func CheckNotifySet(values []smtp.DSNNotify) error
```

CheckNotifySet checks if a DSNNotify array isn't malformed.

<a name="IsPrintableASCII"></a>
## func IsPrintableASCII

```go
func IsPrintableASCII(val string) bool
```

IsPrintableASCII checks if string contains only printable ascii.

<a name="NewDotReader"></a>
## func NewDotReader

```go
func NewDotReader(reader *bufio.Reader, maxMessageBytes int64) io.Reader
```

NewDotReader creates a new dot reader.

<a name="NewDotWriter"></a>
## func NewDotWriter

```go
func NewDotWriter(writer *bufio.Writer) io.WriteCloser
```

NewDotWriter returns a writer that can be used to write a dot\-encoding to w. It takes care of inserting leading dots when necessary, translating line\-ending \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.

See the documentation for Reader's DotReader method for details about dot\-encoding.

<a name="Textproto"></a>
## type Textproto

Textproto is used as a wrapper around a connection to read and write to it

```go
type Textproto struct {
    R   *bufio.Reader
    W   *bufio.Writer

    textproto.Pipeline
    // contains filtered or unexported fields
}
```

<a name="NewTextproto"></a>
### func NewTextproto

```go
func NewTextproto(conn io.ReadWriteCloser, readerSize int, writerSize int, maxLineLength int) *Textproto
```

NewTextproto creates a new connection wrapper.

<a name="Textproto.Close"></a>
### func \(\*Textproto\) Close

```go
func (t *Textproto) Close() error
```

Close closes the connection.

<a name="Textproto.Cmd"></a>
### func \(\*Textproto\) Cmd

```go
func (t *Textproto) Cmd(format string, args ...any) (id uint, err error)
```

Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \\r\\n. Cmd returns the id of the command, for use with StartResponse and EndResponse.

For example, a client might run a HELP command that returns a dot\-body by using:

```
id, err := c.Cmd("HELP")
if err != nil {
	return nil, err
}

c.StartResponse(id)
defer c.EndResponse(id)

if _, _, err = c.ReadCodeLine(110); err != nil {
	return nil, err
}
text, err := c.ReadDotBytes()
if err != nil {
	return nil, err
}
return c.ReadCodeLine(250)
```

<a name="Textproto.PrintfLine"></a>
### func \(\*Textproto\) PrintfLine

```go
func (t *Textproto) PrintfLine(format string, args ...any) error
```

PrintfLine writes the formatted output followed by \\r\\n.

<a name="Textproto.PrintfLineAndFlush"></a>
### func \(\*Textproto\) PrintfLineAndFlush

```go
func (t *Textproto) PrintfLineAndFlush(format string, args ...any) error
```

PrintfLineAndFlush writes the formatted output followed by \\r\\n anf flushes.

<a name="Textproto.ReadCodeLine"></a>
### func \(\*Textproto\) ReadCodeLine

```go
func (t *Textproto) ReadCodeLine(expectCode int) (int, string, error)
```

ReadCodeLine reads a code line.

<a name="Textproto.ReadLine"></a>
### func \(\*Textproto\) ReadLine

```go
func (t *Textproto) ReadLine() (string, error)
```

ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the returned string.

<a name="Textproto.ReadResponse"></a>
### func \(\*Textproto\) ReadResponse

```go
func (t *Textproto) ReadResponse(expectCode int) (code int, message string, err error)
```

ReadResponse reads a multi\-line response of the form:

```
code-message line 1
code-message line 2
...
code message line n
```

where code is a three\-digit status code. The first line starts with the code and a hyphen. The response is terminated by a line that starts with the same code followed by a space. Each line in message is separated by a newline \(\\n\).

See page 36 of RFC 959 \(https://www.ietf.org/rfc/rfc959.txt\) for details of another form of response accepted:

```
code-message line 1
message line 2
...
code message line n
```

If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to &Error\{code, message\}. For example, if expectCode is 31, an error will be returned if the status is not in the range \[310,319\].

An expectCode \<= 0 disables the check of the status code.

<a name="Textproto.Replace"></a>
### func \(\*Textproto\) Replace

```go
func (t *Textproto) Replace(conn io.ReadWriteCloser)
```

Replace conn.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->