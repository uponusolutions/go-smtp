
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/uponusolutions/go-smtp/client/basic.go (83.4%)</option>
				
				<option value="file1">github.com/uponusolutions/go-smtp/client/client.go (63.0%)</option>
				
				<option value="file2">github.com/uponusolutions/go-smtp/client/util.go (98.2%)</option>
				
				<option value="file3">github.com/uponusolutions/go-smtp/error.go (75.0%)</option>
				
				<option value="file4">github.com/uponusolutions/go-smtp/examples/faker/main.go (0.0%)</option>
				
				<option value="file5">github.com/uponusolutions/go-smtp/internal/benchmark/benchmark.go (0.0%)</option>
				
				<option value="file6">github.com/uponusolutions/go-smtp/internal/limit/ratelimit.go (100.0%)</option>
				
				<option value="file7">github.com/uponusolutions/go-smtp/internal/parse/parse.go (79.4%)</option>
				
				<option value="file8">github.com/uponusolutions/go-smtp/internal/textsmtp/dotreader.go (100.0%)</option>
				
				<option value="file9">github.com/uponusolutions/go-smtp/internal/textsmtp/dotwriter.go (79.1%)</option>
				
				<option value="file10">github.com/uponusolutions/go-smtp/internal/textsmtp/textproto.go (87.3%)</option>
				
				<option value="file11">github.com/uponusolutions/go-smtp/internal/textsmtp/util.go (68.8%)</option>
				
				<option value="file12">github.com/uponusolutions/go-smtp/sender.go (88.9%)</option>
				
				<option value="file13">github.com/uponusolutions/go-smtp/server/backend.go (0.0%)</option>
				
				<option value="file14">github.com/uponusolutions/go-smtp/server/bdat.go (79.5%)</option>
				
				<option value="file15">github.com/uponusolutions/go-smtp/server/conn.go (75.8%)</option>
				
				<option value="file16">github.com/uponusolutions/go-smtp/server/encode.go (57.8%)</option>
				
				<option value="file17">github.com/uponusolutions/go-smtp/server/server.go (74.5%)</option>
				
				<option value="file18">github.com/uponusolutions/go-smtp/server/server_options.go (84.3%)</option>
				
				<option value="file19">github.com/uponusolutions/go-smtp/tester/cert.go (85.0%)</option>
				
				<option value="file20">github.com/uponusolutions/go-smtp/tester/compare.go (90.4%)</option>
				
				<option value="file21">github.com/uponusolutions/go-smtp/tester/faker.go (60.0%)</option>
				
				<option value="file22">github.com/uponusolutions/go-smtp/tester/mail.go (100.0%)</option>
				
				<option value="file23">github.com/uponusolutions/go-smtp/tester/server.go (75.8%)</option>
				
				<option value="file24">github.com/uponusolutions/go-smtp/timeout.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "context"
        "crypto/tls"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "net"
        "net/textproto"
        "strconv"
        "strings"

        "github.com/uponusolutions/go-sasl"
        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/internal/textsmtp"
)

// dial returns a connection to an SMTP server at addr. The addr must
// include a port, as in "mail.example.com:smtp".
func (c *Client) dial(ctx context.Context, addr string) (net.Conn, error) <span class="cov4" title="8">{
        dialer := net.Dialer{Timeout: c.dialTimeout}
        return dialer.DialContext(ctx, "tcp", addr)
}</span>

// dialTLS returns a connection to an SMTP server at addr via TLS.
// The addr must include a port, as in "mail.example.com:smtps".
//
// A nil tlsConfig is equivalent to a zero tls.Config.
func (c *Client) dialTLS(ctx context.Context, addr string) (net.Conn, error) <span class="cov0" title="0">{
        tlsDialer := tls.Dialer{
                NetDialer: &amp;net.Dialer{Timeout: c.dialTimeout},
                Config:    c.tlsConfig,
        }
        return tlsDialer.DialContext(ctx, "tcp", addr)
}</span>

// setConn sets the underlying network connection for the client.
func (c *Client) setConn(conn net.Conn) <span class="cov7" title="27">{
        c.conn = conn

        if c.debug != nil </span><span class="cov0" title="0">{
                c.text = textsmtp.NewTextproto(struct {
                        io.Reader
                        io.Writer
                        io.Closer
                }{
                        io.TeeReader(c.conn, c.debug),
                        io.MultiWriter(c.conn, c.debug),
                        c.conn,
                }, c.readerSize, c.writerSize, c.maxLineLength)
        }</span>
        <span class="cov7" title="27">if c.text != nil </span><span class="cov1" title="1">{
                c.text.Replace(conn)
        }</span> else<span class="cov7" title="26"> {
                c.text = textsmtp.NewTextproto(conn, c.readerSize, c.writerSize, c.maxLineLength)
        }</span>
}

// Close closes the connection.
func (c *Client) Close() error <span class="cov7" title="30">{
        if c.conn == nil </span><span class="cov4" title="5">{
                return nil
        }</span>

        <span class="cov7" title="25">err := c.text.Close()
        c.conn = nil
        return err</span>
}

// greet reads the greeting of the server
// if an error occurred the connection is closed
func (c *Client) greet() error <span class="cov7" title="23">{
        // Initial greeting timeout. RFC 5321 recommends 5 minutes.
        timeout := smtp.Timeout(c.conn, c.commandTimeout)
        defer timeout()

        _, msg, err := c.readResponse(220)
        if err != nil </span><span class="cov0" title="0">{
                _ = c.Close()
        }</span>

        <span class="cov7" title="23">if idx := strings.IndexRune(msg, ' '); idx &gt;= 0 </span><span class="cov7" title="23">{
                msg = msg[:idx]
        }</span>

        <span class="cov7" title="23">c.connName = msg

        return err</span>
}

// hello runs a hello exchange
// if an error occurred the connection is closed
func (c *Client) hello() error <span class="cov7" title="24">{
        err := c.ehlo()

        var smtp *smtp.Status
        if err != nil &amp;&amp; errors.As(err, &amp;smtp) &amp;&amp; (smtp.Code == 500 || smtp.Code == 502) </span><span class="cov5" title="11">{
                // The server doesn't support EHLO, fallback to HELO
                err = c.helo()
        }</span>

        <span class="cov7" title="24">if err != nil </span><span class="cov1" title="1">{
                _ = c.Close()
        }</span>

        <span class="cov7" title="24">return err</span>
}

func (c *Client) readResponse(expectCode int) (int, string, error) <span class="cov10" title="110">{
        code, msg, err := c.text.ReadResponse(expectCode)
        if protoErr, ok := err.(*textproto.Error); ok </span><span class="cov7" title="25">{
                err = toSMTPErr(protoErr)
        }</span>
        <span class="cov10" title="110">return code, msg, err</span>
}

// cmd is a convenience function that sends a command and returns the response
// textproto.Error returned by c.text.ReadResponse is converted into smtp.
func (c *Client) cmd(expectCode int, format string, args ...any) (int, string, error) <span class="cov9" title="84">{
        timeout := smtp.Timeout(c.conn, c.commandTimeout)
        defer timeout()

        id, err := c.text.Cmd(format, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>
        <span class="cov9" title="84">c.text.StartResponse(id)
        defer c.text.EndResponse(id)

        return c.readResponse(expectCode)</span>
}

// helo sends the HELO greeting to the server. It should be used only when the
// server does not support ehlo.
func (c *Client) helo() error <span class="cov5" title="12">{
        c.ext = nil
        _, _, err := c.cmd(250, "HELO %s", c.localName)
        return err
}</span>

// ehlo sends the EHLO (extended hello) greeting to the server. It
// should be the preferred greeting for servers that support it.
func (c *Client) ehlo() error <span class="cov7" title="26">{
        cmd := "EHLO"

        _, msg, err := c.cmd(250, "%s %s", cmd, c.localName)
        if err != nil </span><span class="cov5" title="13">{
                return err
        }</span>
        <span class="cov5" title="13">ext := make(map[string]string)
        extList := strings.Split(msg, "\n")
        if len(extList) &gt; 1 </span><span class="cov5" title="11">{
                extList = extList[1:]
                for _, line := range extList </span><span class="cov8" title="40">{
                        i := strings.IndexByte(line, ' ')
                        if i &lt; 0 </span><span class="cov7" title="23">{
                                ext[line] = ""
                        }</span> else<span class="cov6" title="17"> {
                                ext[line[:i]] = line[i+1:]
                        }</span>
                }
        }
        <span class="cov5" title="13">c.ext = ext
        return err</span>
}

// startTLS sends the STARTTLS command and encrypts all further communication.
// Only servers that advertise the STARTTLS extension support this function.
//
// A nil config is equivalent to a zero tls.Config.
//
// If server returns an error, it will be of type *smtp.
// if an error occurred the connection is closed
func (c *Client) startTLS(serverName string) error <span class="cov2" title="2">{
        _, _, err := c.cmd(220, "STARTTLS")
        if err != nil </span><span class="cov1" title="1">{
                _ = c.Quit()
                return err
        }</span>

        <span class="cov1" title="1">config := c.tlsConfig
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;tls.Config{
                        ServerName: serverName,
                }
        }</span> else<span class="cov1" title="1"> if config.ServerName == "" &amp;&amp; serverName != "" </span><span class="cov0" title="0">{
                // Make a copy to avoid polluting argument
                config = config.Clone()
                config.ServerName = serverName
        }</span>

        <span class="cov1" title="1">conn := tls.Client(c.conn, config)

        timeout := smtp.Timeout(conn, c.tlsHandshakeTimeout)
        defer timeout()

        err = conn.Handshake()
        if err != nil </span><span class="cov0" title="0">{
                _ = c.Close()
                return err
        }</span>

        <span class="cov1" title="1">c.setConn(conn)

        err = c.hello()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// TLSConnectionState returns the client's TLS connection state.
// The return values are their zero values if STARTTLS did
// not succeed.
func (c *Client) TLSConnectionState() (tls.ConnectionState, bool) <span class="cov1" title="1">{
        tc, ok := c.conn.(*tls.Conn)
        if !ok </span><span class="cov0" title="0">{
                return tls.ConnectionState{}, ok
        }</span>
        <span class="cov1" title="1">return tc.ConnectionState(), true</span>
}

// Verify checks the validity of an email address on the server.
// If Verify returns nil, the address is valid. A non-nil return
// does not necessarily indicate an invalid address. Many servers
// will not verify addresses for security reasons.
//
// If server returns an error, it will be of type *smtp.
func (c *Client) Verify(addr string, opts *VrfyOptions) error <span class="cov4" title="7">{
        if err := validateLine(addr); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="6">var sb strings.Builder

        sb.Grow(2048)
        fmt.Fprintf(&amp;sb, "VRFY %s", addr)

        // By default utf8 is preferred
        if opts == nil || opts.UTF8 != UTF8Disabled </span><span class="cov4" title="6">{
                if _, ok := c.ext["SMTPUTF8"]; ok </span><span class="cov1" title="1">{
                        sb.WriteString(" SMTPUTF8")
                }</span> else<span class="cov4" title="5"> if opts != nil &amp;&amp; opts.UTF8 == UTF8Force </span><span class="cov1" title="1">{
                        return errors.New("smtp: server does not support SMTPUTF8")
                }</span>
        }

        <span class="cov4" title="5">_, _, err := c.cmd(250, "%s", sb.String())
        return err</span>
}

// Auth authenticates a client using the provided authentication mechanism.
// Only servers that advertise the AUTH extension support this function.
//
// If server returns an error, it will be of type *smtp.
func (c *Client) Auth(a sasl.Client) error <span class="cov3" title="4">{
        encoding := base64.StdEncoding
        mech, resp, err := a.Start()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="4">var resp64 []byte
        if len(resp) &gt; 0 </span><span class="cov3" title="3">{
                resp64 = make([]byte, encoding.EncodedLen(len(resp)))
                encoding.Encode(resp64, resp)
        }</span> else<span class="cov1" title="1"> if resp != nil </span><span class="cov0" title="0">{
                resp64 = []byte{'='}
        }</span>
        <span class="cov3" title="4">code, msg64, err := c.cmd(0, "%s", strings.TrimSpace(fmt.Sprintf("AUTH %s %s", mech, resp64)))
        for err == nil </span><span class="cov3" title="4">{
                var msg []byte
                switch code </span>{
                case 334:<span class="cov0" title="0">
                        msg, err = encoding.DecodeString(msg64)</span>
                case 235:<span class="cov2" title="2">
                        // the last message isn't base64 because it isn't a challenge
                        msg = []byte(msg64)</span>
                default:<span class="cov2" title="2">
                        err = toSMTPErr(&amp;textproto.Error{Code: code, Msg: msg64})</span>
                }
                <span class="cov3" title="4">if err == nil </span><span class="cov2" title="2">{
                        if code == 334 </span><span class="cov0" title="0">{
                                resp, err = a.Next(msg)
                        }</span> else<span class="cov2" title="2"> {
                                resp = nil
                        }</span>
                }
                <span class="cov3" title="4">if err != nil </span><span class="cov2" title="2">{
                        // abort the AUTH
                        _, _, _ = c.cmd(501, "*")
                        break</span>
                }
                <span class="cov2" title="2">if resp == nil </span><span class="cov2" title="2">{
                        break</span>
                }
                <span class="cov0" title="0">resp64 = make([]byte, encoding.EncodedLen(len(resp)))
                encoding.Encode(resp64, resp)
                code, msg64, err = c.cmd(0, "%s", string(resp64))</span>
        }
        <span class="cov3" title="4">return err</span>
}

// Mail issues a MAIL command to the server using the provided email address.
// If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME
// parameter.
// This initiates a mail transaction and is followed by one or more Rcpt calls.
//
// If opts is not nil, MAIL arguments provided in the structure will be added
// to the command. Handling of unsupported options depends on the extension.
//
// If server returns an error, it will be of type *smtp.
func (c *Client) Mail(from string, opts *MailOptions) error <span class="cov6" title="15">{
        if err := validateLine(from); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="14">var sb strings.Builder
        // A high enough power of 2 than 510+14+26+11+9+9+39+500
        sb.Grow(2048)
        fmt.Fprintf(&amp;sb, "MAIL FROM:&lt;%s&gt;", from)
        if _, ok := c.ext["8BITMIME"]; ok </span><span class="cov4" title="6">{
                sb.WriteString(" BODY=8BITMIME")
        }</span>
        <span class="cov6" title="14">if _, ok := c.ext["SIZE"]; ok &amp;&amp; opts != nil &amp;&amp; opts.Size != 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;sb, " SIZE=%v", opts.Size)
        }</span>
        <span class="cov6" title="14">if opts != nil &amp;&amp; opts.RequireTLS </span><span class="cov0" title="0">{
                if _, ok := c.ext["REQUIRETLS"]; !ok </span><span class="cov0" title="0">{
                        return errors.New("smtp: server does not support REQUIRETLS")
                }</span>
                <span class="cov0" title="0">sb.WriteString(" REQUIRETLS")</span>
        }
        // By default utf8 is preferred
        <span class="cov6" title="14">if opts == nil || opts.UTF8 != UTF8Disabled </span><span class="cov6" title="14">{
                if _, ok := c.ext["SMTPUTF8"]; ok </span><span class="cov1" title="1">{
                        sb.WriteString(" SMTPUTF8")
                }</span> else<span class="cov5" title="13"> if opts != nil &amp;&amp; opts.UTF8 == UTF8Force </span><span class="cov1" title="1">{
                        return errors.New("smtp: server does not support SMTPUTF8")
                }</span>
        }
        <span class="cov5" title="13">if _, ok := c.ext["DSN"]; ok &amp;&amp; opts != nil </span><span class="cov2" title="2">{
                switch opts.Return </span>{
                case smtp.DSNReturnFull, smtp.DSNReturnHeaders:<span class="cov1" title="1">
                        fmt.Fprintf(&amp;sb, " RET=%s", string(opts.Return))</span>
                case "":<span class="cov1" title="1"></span>
                        // This space is intentionally left blank
                default:<span class="cov0" title="0">
                        return errors.New("smtp: Unknown RET parameter value")</span>
                }
                <span class="cov2" title="2">if opts.EnvelopeID != "" </span><span class="cov1" title="1">{
                        if !textsmtp.IsPrintableASCII(opts.EnvelopeID) </span><span class="cov0" title="0">{
                                return errors.New("smtp: Malformed ENVID parameter value")
                        }</span>
                        <span class="cov1" title="1">fmt.Fprintf(&amp;sb, " ENVID=%s", encodeXtext(opts.EnvelopeID))</span>
                }
        }
        <span class="cov5" title="13">if opts != nil &amp;&amp; opts.Auth != nil </span><span class="cov1" title="1">{
                if _, ok := c.ext["AUTH"]; ok </span><span class="cov1" title="1">{
                        fmt.Fprintf(&amp;sb, " AUTH=%s", encodeXtext(*opts.Auth))
                }</span>
                // We can safely discard parameter if server does not support AUTH.
        }

        <span class="cov5" title="13">if opts != nil &amp;&amp; opts.XOORG != nil </span><span class="cov0" title="0">{
                if _, ok := c.ext["XOORG"]; ok </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;sb, " XOORG=%s", encodeXtext(*opts.XOORG))
                }</span>
                // We can safely discard parameter if server does not support AUTH.
        }

        <span class="cov5" title="13">_, _, err := c.cmd(250, "%s", sb.String())
        return err</span>
}

// Rcpt issues a RCPT command to the server using the provided email address.
// A call to Rcpt must be preceded by a call to Mail and may be followed by
// a Data call or another Rcpt call.
//
// If opts is not nil, RCPT arguments provided in the structure will be added
// to the command. Handling of unsupported options depends on the extension.
//
// If server returns an error, it will be of type *smtp.
func (c *Client) Rcpt(to string, opts *smtp.RcptOptions) error <span class="cov5" title="10">{
        if err := validateLine(to); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="9">var sb strings.Builder
        // A high enough power of 2 than 510+29+501
        sb.Grow(2048)
        fmt.Fprintf(&amp;sb, "RCPT TO:&lt;%s&gt;", to)
        if _, ok := c.ext["DSN"]; ok &amp;&amp; opts != nil </span><span class="cov3" title="4">{
                if len(opts.Notify) != 0 </span><span class="cov2" title="2">{
                        sb.WriteString(" NOTIFY=")
                        if err := textsmtp.CheckNotifySet(opts.Notify); err != nil </span><span class="cov0" title="0">{
                                return errors.New("smtp: Malformed NOTIFY parameter value")
                        }</span>
                        <span class="cov2" title="2">for i, v := range opts.Notify </span><span class="cov3" title="3">{
                                if i != 0 </span><span class="cov1" title="1">{
                                        sb.WriteString(",")
                                }</span>
                                <span class="cov3" title="3">sb.WriteString(string(v))</span>
                        }
                }
                <span class="cov3" title="4">if opts.OriginalRecipient != "" </span><span class="cov3" title="4">{
                        var enc string
                        switch opts.OriginalRecipientType </span>{
                        case smtp.DSNAddressTypeRFC822:<span class="cov1" title="1">
                                if !textsmtp.IsPrintableASCII(opts.OriginalRecipient) </span><span class="cov0" title="0">{
                                        return errors.New("smtp: Illegal address")
                                }</span>
                                <span class="cov1" title="1">enc = encodeXtext(opts.OriginalRecipient)</span>
                        case smtp.DSNAddressTypeUTF8:<span class="cov3" title="3">
                                if _, ok := c.ext["SMTPUTF8"]; ok </span><span class="cov1" title="1">{
                                        enc = encodeUTF8AddrUnitext(opts.OriginalRecipient)
                                }</span> else<span class="cov2" title="2"> {
                                        enc = encodeUTF8AddrXtext(opts.OriginalRecipient)
                                }</span>
                        default:<span class="cov0" title="0">
                                return errors.New("smtp: Unknown address type")</span>
                        }
                        <span class="cov3" title="4">fmt.Fprintf(&amp;sb, " ORCPT=%s;%s", string(opts.OriginalRecipientType), enc)</span>
                }
        }
        <span class="cov5" title="9">if _, _, err := c.cmd(25, "%s", sb.String()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="9">return nil</span>
}

// DataCloser implement an io.WriteCloser with the additional
// CloseWithResponse function.
type DataCloser struct {
        c *Client
        io.WriteCloser
        closed bool
}

// CloseWithResponse closes the data closer and returns code, msg
func (d *DataCloser) CloseWithResponse() (code int, msg string, err error) <span class="cov3" title="3">{
        if d.closed </span><span class="cov0" title="0">{
                return 0, "", errors.New("smtp: data writer closed twice")
        }</span>

        <span class="cov3" title="3">if err := d.WriteCloser.Close(); err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>

        <span class="cov3" title="3">timeout := smtp.Timeout(d.c.conn, d.c.submissionTimeout)
        defer timeout()

        code, msg, err = d.c.readResponse(250)

        d.closed = true
        return code, msg, err</span>
}

// Close closes the data closer.
func (d *DataCloser) Close() error <span class="cov1" title="1">{
        _, _, err := d.CloseWithResponse()
        return err
}</span>

// Data issues a DATA command to the server and returns a writer that
// can be used to write the mail headers and body. The caller should
// close the writer before calling any more methods on c. A call to
// Data must be preceded by one or more calls to Rcpt.
//
// If server returns an error, it will be of type *smtp.
func (c *Client) Data() (*DataCloser, error) <span class="cov3" title="3">{
        _, _, err := c.cmd(354, "DATA")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">return &amp;DataCloser{c: c, WriteCloser: textsmtp.NewDotWriter(c.text.W)}, nil</span>
}

// Extension reports whether an extension is support by the server.
// The extension name is case-insensitive. If the extension is supported,
// Extension also returns a string that contains any parameters the
// server specifies for the extension.
func (c *Client) Extension(ext string) (bool, string) <span class="cov6" title="20">{
        ext = strings.ToUpper(ext)
        param, ok := c.ext[ext]
        return ok, param
}</span>

// SupportsAuth checks whether an authentication mechanism is supported.
func (c *Client) SupportsAuth(mech string) bool <span class="cov1" title="1">{
        mechs, ok := c.ext["AUTH"]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">for _, m := range strings.Split(mechs, " ") </span><span class="cov2" title="2">{
                if strings.EqualFold(m, mech) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// MaxMessageSize returns the maximum message size accepted by the server.
// 0 means unlimited.
//
// If the server doesn't convey this information, ok = false is returned.
func (c *Client) MaxMessageSize() (size int, ok bool) <span class="cov1" title="1">{
        v := c.ext["SIZE"]
        if v == "" </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov1" title="1">size, err := strconv.Atoi(v)
        if err != nil || size &lt; 0 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov1" title="1">return size, true</span>
}

// Reset sends the RSET command to the server, aborting the current mail
// transaction.
func (c *Client) Reset() error <span class="cov1" title="1">{
        if _, _, err := c.cmd(250, "RSET"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Noop sends the NOOP command to the server. It does nothing but check
// that the connection to the server is okay.
func (c *Client) Noop() error <span class="cov1" title="1">{
        _, _, err := c.cmd(250, "NOOP")
        return err
}</span>

// Quit sends the QUIT command and closes the connection to the server.
// If Quit fails the connection will still be closed.
func (c *Client) Quit() error <span class="cov5" title="10">{
        if c.conn == nil </span><span class="cov3" title="4">{
                return nil
        }</span>
        <span class="cov4" title="6">_, _, err := c.cmd(221, "QUIT")
        if err != nil </span><span class="cov1" title="1">{
                _ = c.Close()
                return err
        }</span>
        <span class="cov4" title="5">return c.Close()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "bytes"
        "context"
        "crypto/tls"
        "errors"
        "io"
        "net"
        "strings"
        "time"

        "github.com/uponusolutions/go-sasl"
        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/internal/textsmtp"
)

// Security describes how the connection is etablished.
type Security int32

const (
        // SecurityPreferStartTLS tries to use StartTls but fallbacks to plain.
        SecurityPreferStartTLS Security = 0
        // SecurityPlain is always just a plain connection.
        SecurityPlain Security = 1
        // SecurityTLS does a implicit tls connection.
        SecurityTLS Security = 2
        // SecurityStartTLS always does starttls.
        SecurityStartTLS Security = 3
)

// UTF8 describes how SMTPUTF8 is used.
type UTF8 int32

const (
        // UTF8Prefer uses SMTPUTF8 if possible.
        UTF8Prefer UTF8 = 0
        // UTF8Force always uses SMTPUTF8.
        UTF8Force UTF8 = 1
        // UTF8Disabled never uses SMTPUTF8.
        UTF8Disabled UTF8 = 2
)

// MailOptions contains parameters for the MAIL command.
type MailOptions struct {
        // Size of the body. Can be 0 if not specified by client.
        Size int64

        // TLS is required for the message transmission.
        //
        // The message should be rejected if it can't be transmitted
        // with TLS.
        RequireTLS bool

        // The message envelope or message header contains UTF-8-encoded strings.
        // This flag is set by SMTPUTF8-aware (RFC 6531) client.
        UTF8 UTF8

        // Value of RET= argument, FULL or HDRS.
        Return smtp.DSNReturn

        // Envelope identifier set by the client.
        EnvelopeID string

        // Accepted Domain from Exchange Online, e.g. from OutgoingConnector
        XOORG *string

        // The authorization identity asserted by the message sender in decoded
        // form with angle brackets stripped.
        //
        // nil value indicates missing AUTH, non-nil empty string indicates
        // AUTH=&lt;&gt;.
        //
        // Defined in RFC 4954.
        Auth *string
}

// VrfyOptions contains parameters for the VRFY command.
type VrfyOptions struct {
        // The message envelope or message header contains UTF-8-encoded strings.
        // This flag is set by SMTPUTF8-aware (RFC 6531) client.
        UTF8 UTF8
}

// Client is an SMTP client.
// It sends one or more mails to a SMTP server over a single connection.
// TODO: Add context support.
type Client struct {
        serverAddresses    [][]string // Format address:port.
        serverAddressIndex int        // first server address to try
        tlsConfig          *tls.Config
        saslClient         sasl.Client

        // keep a reference to the connection so it can be used to create a TLS
        // connection later
        conn        net.Conn
        connAddress string // Format address:port.
        connName    string // server greet name

        text      *textsmtp.Textproto
        ext       map[string]string // supported extensions
        localName string            // the name to use in HELO/EHLO/LHLO

        // Time to wait for tls handshake to succeed.
        tlsHandshakeTimeout time.Duration

        // Time to wait for dial to succeed.
        dialTimeout time.Duration

        // Time to wait for command responses (this includes 3xx reply to DATA).
        commandTimeout time.Duration

        // Time to wait for responses after final dot.
        submissionTimeout time.Duration

        // Max line length, defaults to 2000
        maxLineLength int

        // Reader size
        readerSize int

        // Writer size
        writerSize int

        // Logger for all network activity.
        debug io.Writer

        // Defines the connection is secured
        security Security

        mailOptions MailOptions
}

// New returns a new SMTP client.
// When not set via options the address 127.0.0.1:25 is used.
// When not set via options a default tls.Config is used.
func New(opts ...Option) *Client <span class="cov10" title="28">{
        c := &amp;Client{
                serverAddresses: [][]string{{"127.0.0.1:25"}},

                security: SecurityPreferStartTLS,

                localName: "localhost",
                // As recommended by RFC 5321. For DATA command reply (3xx one) RFC
                // recommends a slightly shorter timeout but we do not bother
                // differentiating these.
                commandTimeout: 5 * time.Minute,
                // 10 minutes + 2 minute buffer in case the server is doing transparent
                // forwarding and also follows recommended timeouts.
                submissionTimeout: 12 * time.Minute,
                // 30 seconds, very generous
                tlsHandshakeTimeout: 30 * time.Second,

                // 30 seconds, very generous
                dialTimeout: 30 * time.Second,

                // Doubled maximum line length per RFC 5321 (Section 4.5.3.1.6)
                maxLineLength: 2000,

                // Reader buffer of textproto
                readerSize: 4096,
                // Writer buffer of textproto
                writerSize: 4096,
        }

        for _, o := range opts </span><span class="cov7" title="13">{
                o(c)
        }</span>

        <span class="cov10" title="28">return c</span>
}

// Option defines a client option.
type Option func(c *Client)

// WithServerAddresses sets the SMTP servers address.
func WithServerAddresses(addrs ...string) Option <span class="cov6" title="9">{
        return func(c *Client) </span><span class="cov6" title="9">{
                c.serverAddresses = [][]string{addrs}
        }</span>
}

// WithServerAddressesPrio sets the SMTP servers address.
func WithServerAddressesPrio(addrs ...[]string) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.serverAddresses = addrs
        }</span>
}

// WithServerAddressIndex sets the SMTP server index.
func WithServerAddressIndex(index int) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.serverAddressIndex = index
        }</span>
}

// WithMailOptions sets the mail options.
func WithMailOptions(mailOptions MailOptions) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.mailOptions = mailOptions
        }</span>
}

// WithSubmissionTimeout sets the submission timeout.
func WithSubmissionTimeout(submissionTimeout time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.submissionTimeout = submissionTimeout
        }</span>
}

// WithCommandTimeout sets the command timeout.
func WithCommandTimeout(commandTimeout time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.commandTimeout = commandTimeout
        }</span>
}

// WithDialTimeout sets the dial timeout.
func WithDialTimeout(dialTimeout time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.dialTimeout = dialTimeout
        }</span>
}

// WithTlsHandshakeTimeout sets tls handshake timeout.
func WithTlsHandshakeTimeout(tlsHandshakeTimeout time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.tlsHandshakeTimeout = tlsHandshakeTimeout
        }</span>
}

// WithLocalName sets the HELO local name.
func WithLocalName(localName string) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.localName = localName
        }</span>
}

// WithTLSConfig sets the TLS config.
func WithTLSConfig(cfg *tls.Config) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.tlsConfig = cfg
        }</span>
}

// WithSecurity sets the TLS config.
func WithSecurity(security Security) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.security = security
        }</span>
}

// WithSASLClient sets the SASL client.
func WithSASLClient(cl sasl.Client) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.saslClient = cl
        }</span>
}

// WithMaxLineLength sets the max line length.
func WithMaxLineLength(maxLineLength int) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.maxLineLength = maxLineLength
        }</span>
}

// WithReaderSize sets the reader size.
func WithReaderSize(readerSize int) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.readerSize = readerSize
        }</span>
}

// WithWriterSize sets the reader size.
func WithWriterSize(writerSize int) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.writerSize = writerSize
        }</span>
}

// ServerAddresses returns the server address.
func (c *Client) ServerAddresses() [][]string <span class="cov1" title="1">{
        return c.serverAddresses
}</span>

// ServerAddress returns the current server address.
func (c *Client) ServerAddress() string <span class="cov5" title="6">{
        return c.connAddress
}</span>

// ServerName returns the current server name.
func (c *Client) ServerName() string <span class="cov4" title="4">{
        return c.connName
}</span>

// Connect connects to one of the available SMTP server.
// When server supports auth and clients SaslClient is set, auth is called.
// Security is enforced like configured (Plain, TLS, StartTLS or PreferStartTLS)
// If an error occures, the connection is closed if open.
func (c *Client) Connect(ctx context.Context) error <span class="cov6" title="8">{
        // verify if local name is valid
        if strings.ContainsAny(c.localName, "\n\r") </span><span class="cov1" title="1">{
                return errors.New("smtp: the local name must not contain CR or LF")
        }</span>

        <span class="cov6" title="7">var err error

        for i := 0; i &lt; len(c.serverAddresses); i++ </span><span class="cov6" title="7">{
                for p := 0; p &lt; len(c.serverAddresses[i]); p++ </span><span class="cov6" title="8">{
                        // use c.serverAddressIndex
                        address := c.serverAddresses[i][(p+c.serverAddressIndex)%len(c.serverAddresses[i])]
                        err = c.connectAddress(ctx, address)
                        if err == nil </span><span class="cov6" title="7">{
                                c.connAddress = address
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return err</span>
}

// Connect connects to the SMTP server (addr).
// When server supports auth and clients SaslClient is set, auth is called.
// Security is enforced like configured (Plain, TLS, StartTLS or PreferStartTLS)
// If an error occures, the connection is closed if open.
func (c *Client) connectAddress(ctx context.Context, addr string) error <span class="cov6" title="8">{
        var err error
        var conn net.Conn

        switch c.security </span>{
        case SecurityPlain:<span class="cov0" title="0">
                fallthrough</span>
        case SecurityStartTLS:<span class="cov1" title="1">
                fallthrough</span>
        case SecurityPreferStartTLS:<span class="cov6" title="8">
                conn, err = c.dial(ctx, addr)</span>
        case SecurityTLS:<span class="cov0" title="0">
                conn, err = c.dialTLS(ctx, addr)</span>
        }

        <span class="cov6" title="8">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="7">c.setConn(conn)

        if err = c.greet(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="7">if err = c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="7">if c.security == SecurityStartTLS || c.security == SecurityPreferStartTLS </span><span class="cov6" title="7">{
                if ok, _ := c.Extension("STARTTLS"); !ok </span><span class="cov5" title="6">{
                        if c.security == SecurityStartTLS </span><span class="cov0" title="0">{
                                _ = c.Quit()
                                return errors.New("smtp: server doesn't support STARTTLS")
                        }</span>
                } else<span class="cov1" title="1"> {
                        serverName, _, _ := net.SplitHostPort(addr)

                        err = c.startTLS(serverName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov6" title="7">return c.auth()</span>
}

func (c *Client) auth() error <span class="cov6" title="7">{
        // Authenticate if authentication is possible and sasl client available.
        if ok, _ := c.Extension("AUTH"); ok &amp;&amp; c.saslClient != nil </span><span class="cov0" title="0">{
                if err := c.Auth(c.saslClient); err != nil </span><span class="cov0" title="0">{
                        _ = c.Quit()
                        return err
                }</span>
        }
        <span class="cov6" title="7">return nil</span>
}

func (c *Client) prepare(from string, rcpt []string) (*DataCloser, error) <span class="cov4" title="4">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return nil, errors.New("client is nil or not connected")
        }</span>

        <span class="cov4" title="4">if len(rcpt) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("no recipients")
        }</span>

        // MAIL FROM:
        <span class="cov4" title="4">if err := c.Mail(from, &amp;c.mailOptions); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        // RCPT TO:
        <span class="cov2" title="2">for _, addr := range rcpt </span><span class="cov4" title="4">{
                if err := c.Rcpt(addr, &amp;smtp.RcptOptions{}); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // DATA
        <span class="cov2" title="2">w, err := c.Data()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return w, nil</span>
}

// SendMail will use an existing connection to send an email from
// address from, to addresses to, with message r.
//
// This function does not start TLS, nor does it perform authentication. Use
// DialStartTLS and Auth before-hand if desirable.
//
// The addresses in the to parameter are the SMTP RCPT addresses.
//
// The r parameter should be an RFC 822-style email with headers
// first, a blank line, and then the message body. The lines of r
// should be CRLF terminated. The r headers should usually include
// fields such as "From", "To", "Subject", and "Cc".  Sending "Bcc"
// messages is accomplished by including an email address in the to
// parameter but not including it in the r headers.
func (c *Client) SendMail(from string, rcpt []string, in io.Reader) (code int, msg string, err error) <span class="cov4" title="4">{
        w, err := c.prepare(from, rcpt)
        if err != nil </span><span class="cov2" title="2">{
                return 0, "", err
        }</span>

        <span class="cov2" title="2">_, err = io.Copy(w, in)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>

        <span class="cov2" title="2">return w.CloseWithResponse()</span>
}

// SetXOORG set xoorg support
func (c *Client) SetXOORG(xoorg *string) <span class="cov0" title="0">{
        c.mailOptions.XOORG = xoorg
}</span>

// Send implements enmime.Sender interface.
func (c *Client) Send(from string, rcpt []string, msg []byte) error <span class="cov1" title="1">{
        _, _, err := c.SendMail(from, rcpt, bytes.NewBuffer(msg))
        return err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package client

import (
        "errors"
        "net/textproto"
        "strconv"
        "strings"

        "github.com/uponusolutions/go-smtp"
)

func parseEnhancedCode(s string) (smtp.EnhancedCode, error) <span class="cov7" title="15">{
        parts := strings.Split(s, ".")
        if len(parts) != 3 </span><span class="cov6" title="11">{
                return smtp.EnhancedCode{}, errors.New("wrong amount of enhanced code parts")
        }</span>

        <span class="cov4" title="4">code := smtp.EnhancedCode{}
        for i, part := range parts </span><span class="cov7" title="12">{
                num, err := strconv.Atoi(part)
                if err != nil </span><span class="cov0" title="0">{
                        return code, err
                }</span>
                <span class="cov7" title="12">code[i] = num</span>
        }
        <span class="cov4" title="4">return code, nil</span>
}

// toSMTPErr converts textproto.Error into smtp, parsing
// enhanced status code if it is present.
func toSMTPErr(protoErr *textproto.Error) *smtp.Status <span class="cov9" title="27">{
        smtpErr := &amp;smtp.Status{
                Code:    protoErr.Code,
                Message: protoErr.Msg,
        }

        parts := strings.SplitN(protoErr.Msg, " ", 2)
        if len(parts) != 2 </span><span class="cov7" title="12">{
                return smtpErr
        }</span>

        <span class="cov7" title="15">enchCode, err := parseEnhancedCode(parts[0])
        if err != nil </span><span class="cov6" title="11">{
                return smtpErr
        }</span>

        <span class="cov4" title="4">msg := parts[1]

        // Per RFC 2034, enhanced code should be prepended to each line.
        msg = strings.ReplaceAll(msg, "\n"+parts[0]+" ", "\n")

        smtpErr.EnhancedCode = enchCode
        smtpErr.Message = msg
        return smtpErr</span>
}

// validateLine checks to see if a line has CR or LF.
func validateLine(line string) error <span class="cov9" title="32">{
        if strings.ContainsAny(line, "\n\r") </span><span class="cov3" title="3">{
                return errors.New("smtp: a line must not contain CR or LF")
        }</span>
        <span class="cov9" title="29">return nil</span>
}

func encodeXtext(raw string) string <span class="cov3" title="3">{
        var out strings.Builder
        out.Grow(len(raw))

        for _, ch := range raw </span><span class="cov10" title="39">{
                switch </span>{
                case ch &gt;= '!' &amp;&amp; ch &lt;= '~' &amp;&amp; ch != '+' &amp;&amp; ch != '=':<span class="cov9" title="36">
                        // printable non-space US-ASCII except '+' and '='
                        out.WriteRune(ch)</span>
                default:<span class="cov3" title="3">
                        out.WriteRune('+')
                        out.WriteString(strings.ToUpper(strconv.FormatInt(int64(ch), 16)))</span>
                }
        }
        <span class="cov3" title="3">return out.String()</span>
}

// encodeUTF8AddrUnitext encodes raw string to the utf-8-addr-unitext form in RFC 6533.
func encodeUTF8AddrUnitext(raw string) string <span class="cov1" title="1">{
        var out strings.Builder
        out.Grow(len(raw))

        for _, ch := range raw </span><span class="cov7" title="15">{
                switch </span>{
                case ch &gt;= '!' &amp;&amp; ch &lt;= '~' &amp;&amp; ch != '+' &amp;&amp; ch != '=':<span class="cov6" title="8">
                        // printable non-space US-ASCII except '+' and '='
                        out.WriteRune(ch)</span>
                case ch &lt;= '\x7F':<span class="cov1" title="1">
                        // other ASCII: CTLs, space and specials
                        out.WriteRune('\\')
                        out.WriteRune('x')
                        out.WriteRune('{')
                        out.WriteString(strings.ToUpper(strconv.FormatInt(int64(ch), 16)))
                        out.WriteRune('}')</span>
                default:<span class="cov5" title="6">
                        // UTF-8 non-ASCII
                        out.WriteRune(ch)</span>
                }
        }
        <span class="cov1" title="1">return out.String()</span>
}

// encodeUTF8AddrXtext encodes raw string to the utf-8-addr-xtext form in RFC 6533.
func encodeUTF8AddrXtext(raw string) string <span class="cov2" title="2">{
        var out strings.Builder
        out.Grow(len(raw))

        for _, ch := range raw </span><span class="cov9" title="32">{
                switch </span>{
                case ch &gt;= '!' &amp;&amp; ch &lt;= '~' &amp;&amp; ch != '+' &amp;&amp; ch != '=':<span class="cov8" title="24">
                        // printable non-space US-ASCII except '+' and '='
                        out.WriteRune(ch)</span>
                default:<span class="cov6" title="8">
                        out.WriteRune('\\')
                        out.WriteRune('x')
                        out.WriteRune('{')
                        out.WriteString(strings.ToUpper(strconv.FormatInt(int64(ch), 16)))
                        out.WriteRune('}')</span>
                }
        }
        <span class="cov2" title="2">return out.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package smtp

import (
        "fmt"
)

// EnhancedCode is the SMTP enhanced code
type EnhancedCode [3]int

// Status specifies the error code, enhanced error code (if any) and
// message returned by the server.
type Status struct {
        Code         int
        EnhancedCode EnhancedCode
        Message      string
}

// NoEnhancedCode is used to indicate that enhanced error code should not be
// included in response.
//
// Note that RFC 2034 requires an enhanced code to be included in all 2xx, 4xx
// and 5xx responses. This constant is exported for use by extensions, you
// should probably use EnhancedCodeNotSet instead.
var NoEnhancedCode = EnhancedCode{-1, -1, -1}

// EnhancedCodeNotSet is a nil value of EnhancedCode field in smtp, used
// to indicate that backend failed to provide enhanced status code. X.0.0 will
// be used (X is derived from error code).
var EnhancedCodeNotSet = EnhancedCode{0, 0, 0}

// NewStatus creates a new status.
func NewStatus(code int, enhCode EnhancedCode, msg string) *Status <span class="cov10" title="203">{
        return &amp;Status{
                Code:         code,
                EnhancedCode: enhCode,
                Message:      msg,
        }
}</span>

// Error returns a error string.
func (err *Status) Error() string <span class="cov3" title="4">{
        s := fmt.Sprintf("SMTP error %03d", err.Code)
        if err.Message != "" </span><span class="cov3" title="4">{
                s += ": " + err.Message
        }</span>
        <span class="cov3" title="4">return s</span>
}

// Positive returns true if the status code is 2xx.
func (err *Status) Positive() bool <span class="cov1" title="1">{
        return err.Code/100 == 2
}</span>

// Temporary returns true if the status code is 4xx.
func (err *Status) Temporary() bool <span class="cov0" title="0">{
        return err.Code/100 == 4
}</span>

// Permanent returns true if the status code is 5xx.
func (err *Status) Permanent() bool <span class="cov0" title="0">{
        return err.Code/100 == 5
}</span>

var (
        // Reset is returned by Reader passed to Data function if client does not
        // send another BDAT command and instead issues RSET command.
        Reset = &amp;Status{
                Code:         250,
                EnhancedCode: EnhancedCode{2, 0, 0},
                Message:      "Session reset",
        }
        // VRFY default return.
        VRFY = &amp;Status{
                Code:         252,
                EnhancedCode: EnhancedCode{2, 5, 0},
                Message:      "Cannot VRFY user, but will accept message",
        }
        // Noop default return.
        Noop = &amp;Status{
                Code:         250,
                EnhancedCode: EnhancedCode{2, 0, 0},
                Message:      "I have successfully done nothing",
        }
        // Quit is returned by Reader passed to Data function if client does not
        // send another BDAT command and instead issues QUIT command.
        Quit = &amp;Status{
                Code:         221,
                EnhancedCode: EnhancedCode{2, 0, 0},
                Message:      "Bye",
        }
        // ErrConnection is returned if a connection error occurs.
        ErrConnection = &amp;Status{
                Code:         421,
                EnhancedCode: EnhancedCode{4, 4, 0},
                Message:      "Connection error, sorry",
        }
        // ErrDataTooLarge is returned if the maximum message size is exceeded.
        ErrDataTooLarge = &amp;Status{
                Code:         552,
                EnhancedCode: EnhancedCode{5, 3, 4},
                Message:      "Maximum message size exceeded",
        }
        // ErrAuthFailed is returned if the authentication failed.
        ErrAuthFailed = &amp;Status{
                Code:         535,
                EnhancedCode: EnhancedCode{5, 7, 8},
                Message:      "Authentication failed",
        }
        // ErrAuthRequired is returned if the authentication is required.
        ErrAuthRequired = &amp;Status{
                Code:         502,
                EnhancedCode: EnhancedCode{5, 7, 0},
                Message:      "Please authenticate first",
        }
        // ErrAuthUnsupported is returned if the authentication is not supported.
        ErrAuthUnsupported = &amp;Status{
                Code:         502,
                EnhancedCode: EnhancedCode{5, 7, 0},
                Message:      "Authentication not supported",
        }
        // ErrAuthUnknownMechanism is returned if the authentication unsupported.
        ErrAuthUnknownMechanism = &amp;Status{
                Code:         504,
                EnhancedCode: EnhancedCode{5, 7, 4},
                Message:      "Unsupported authentication mechanism",
        }
        // ErrNoRecipients is returned if no recipients are set.
        ErrNoRecipients = &amp;Status{
                Code:         502,
                EnhancedCode: EnhancedCode{5, 5, 1},
                Message:      "Missing RCPT TO command.",
        }
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "net/smtp"
        "os"
        "os/signal"

        "github.com/uponusolutions/go-smtp/tester"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
        defer cancel()

        s := tester.Standard()

        listen, err := s.Listen()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("error listen server", slog.Any("error", err))
        }</span>

        <span class="cov0" title="0">addr := listen.Addr().String()

        go func() </span><span class="cov0" title="0">{
                if err := s.Serve(ctx, listen); err != nil </span><span class="cov0" title="0">{
                        slog.Error("smtp server response %s", slog.Any("error", err))
                }</span>
        }()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := s.Close(); err != nil </span><span class="cov0" title="0">{
                        slog.Error("error closing server", slog.Any("error", err))
                }</span>
        }()

        // Send email.
        <span class="cov0" title="0">from := "alice@i.com"
        to := []string{"bob@e.com", "mal@b.com"}
        msg := []byte("Test\r\n")
        if err := smtp.SendMail(addr, nil, from, to, msg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Lookup email.
        <span class="cov0" title="0">m, found := tester.GetBackend(s).Load(from, to)
        fmt.Printf("Found %t, mail %+v\n", found, m)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package benchmark

import (
        "bytes"
        "context"
        "crypto/tls"
        "embed"
        "io"
        "log/slog"

        "github.com/uponusolutions/go-sasl"
        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/client"
        "github.com/uponusolutions/go-smtp/server"
)

//go:embed testdata/*
var embedFSTestadata embed.FS

type message struct {
        From     string
        To       []string
        RcptOpts []*smtp.RcptOptions
        Data     []byte
        Opts     *smtp.MailOptions
}

type backend struct{}

func (be *backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error) <span class="cov0" title="0">{
        return ctx, &amp;session{backend: be}, nil
}</span>

type session struct {
        backend *backend

        msg *message
}

func (*session) Logger(_ context.Context) *slog.Logger <span class="cov0" title="0">{
        return nil
}</span>

func (*session) AuthMechanisms(_ context.Context) []string <span class="cov0" title="0">{
        return []string{"PLAIN"}
}</span>

func (*session) Auth(_ context.Context, _ string) (sasl.Server, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (s *session) Reset(ctx context.Context, _ bool) (context.Context, error) <span class="cov0" title="0">{
        s.msg = &amp;message{}
        return ctx, nil
}</span>

func (*session) Close(_ context.Context, _ error) {<span class="cov0" title="0">
}</span>

func (*session) STARTTLS(_ context.Context, tls *tls.Config) (*tls.Config, error) <span class="cov0" title="0">{
        return tls, nil
}</span>

func (*session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *session) Mail(ctx context.Context, from string, opts *smtp.MailOptions) error <span class="cov0" title="0">{
        _, _ = s.Reset(ctx, false)
        s.msg.From = from
        s.msg.Opts = opts
        return nil
}</span>

func (s *session) Rcpt(_ context.Context, to string, opts *smtp.RcptOptions) error <span class="cov0" title="0">{
        s.msg.To = append(s.msg.To, to)
        s.msg.RcptOpts = append(s.msg.RcptOpts, opts)
        return nil
}</span>

func (s *session) Data(_ context.Context, r func() io.Reader) (string, error) <span class="cov0" title="0">{
        b, err := io.ReadAll(r())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">s.msg.Data = b

        // s.backend.messages = append(s.backend.messages, s.msg)

        return "", nil</span>
}

func testServer(bei *backend, opts ...server.Option) (be *backend, s *server.Server, port string, err error) <span class="cov0" title="0">{
        if bei == nil </span><span class="cov0" title="0">{
                be = new(backend)
        }</span> else<span class="cov0" title="0"> {
                be = bei
        }</span>

        <span class="cov0" title="0">curOpts := []server.Option{
                server.WithAddr("127.0.0.1:0"),
                server.WithBackend(be),
                server.WithMaxLineLength(2000),
                server.WithHostname("localhost"),
        }

        curOpts = append(curOpts, opts...)

        s = server.New(
                curOpts...,
        )

        ctx := context.Background()

        l, err := s.Listen()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, "", err
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // nolint: revive
                _ = s.Serve(ctx, l)
        }</span>()

        <span class="cov0" title="0">return be, s, l.Addr().String(), nil</span>
}

func sendMailCon(c *client.Client, data []byte) error <span class="cov0" title="0">{
        from := "alice@internal.com"
        recipients := []string{"bob@external.com", "tim@external.com"}

        in := bytes.NewReader(data)

        _, _, err := c.SendMail(from, recipients, in)
        return err
}</span>

func sendMail(addr string, data []byte) error <span class="cov0" title="0">{
        c := client.New(
                client.WithServerAddresses(addr),
                client.WithSecurity(client.SecurityPlain),
                client.WithMailOptions(client.MailOptions{Size: int64(len(data))}),
        )

        err := c.Connect(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err = sendMailCon(c, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.Quit()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package limit

import (
        "errors"
        "time"
)

// ErrRatelimit is returned if limit reached and strict mode is enabled.
var ErrRatelimit = errors.New("rate limit occurred")

// RatelimitConfig configures a rate limit.
type RatelimitConfig struct {
        Rate     int
        Duration time.Duration
        Strict   bool
}

// Ratelimit is used e.g. to limit the calls to a function.
type Ratelimit struct {
        start  time.Time
        count  int
        config *RatelimitConfig
}

// New creates a new rate limit.
func New(config *RatelimitConfig) *Ratelimit <span class="cov3" title="2">{
        return &amp;Ratelimit{
                config: config,
                start:  time.Now(),
                count:  0,
        }
}</span>

// Take returns when it is allowed to do something again.
func (c *Ratelimit) Take() error <span class="cov10" title="9">{
        c.count++
        if c.count &lt;= c.config.Rate </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov8" title="7">now := time.Now()

        dur := now.Sub(c.start)

        if dur &lt; c.config.Duration </span><span class="cov3" title="2">{
                if c.config.Strict </span><span class="cov1" title="1">{
                        return ErrRatelimit
                }</span>
                <span class="cov1" title="1">time.Sleep(c.config.Duration - dur)
                now = time.Now()</span>
        }

        <span class="cov8" title="6">c.start = now
        c.count = 1

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package parse

import (
        "errors"
        "fmt"
        "strings"
)

// CutPrefixFold is a version of strings.CutPrefix which is case-insensitive.
func CutPrefixFold(s, prefix string) (string, bool) <span class="cov5" title="73">{
        if len(s) &lt; len(prefix) || !strings.EqualFold(s[:len(prefix)], prefix) </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov5" title="73">return s[len(prefix):], true</span>
}

// Cmd parses a line and returns the command, argument or an error.
func Cmd(line string) (cmd string, arg string, err error) <span class="cov7" title="228">{
        line = strings.TrimRight(line, "\r\n")

        l := len(line)
        switch </span>{
        case strings.HasPrefix(strings.ToUpper(line), "STARTTLS"):<span class="cov1" title="2">
                return "STARTTLS", "", nil</span>
        case l == 0:<span class="cov0" title="0">
                return "", "", nil</span>
        case l &lt; 4:<span class="cov0" title="0">
                return "", "", fmt.Errorf("command too short: %q", line)</span>
        case l == 4:<span class="cov4" title="26">
                return strings.ToUpper(line), "", nil</span>
        case l == 5:<span class="cov0" title="0">
                // Too long to be only command, too short to have args
                return "", "", fmt.Errorf("mangled command: %q", line)</span>
        }

        // If we made it here, command is long enough to have args
        <span class="cov6" title="200">if line[4] != ' ' </span><span class="cov1" title="2">{
                // There wasn't a space after the command?
                return "", "", fmt.Errorf("mangled command: %q", line)
        }</span>

        <span class="cov6" title="198">return strings.ToUpper(line[0:4]), strings.TrimSpace(line[5:]), nil</span>
}

// Args takes the arguments proceeding a command and files them
// into a map[string]string after uppercasing each key.  Sample arg
// string:
//
//        " BODY=8BITMIME SIZE=1024 SMTPUTF8"
//
// The leading space is mandatory.
func Args(s string) (map[string]string, error) <span class="cov5" title="73">{
        argMap := map[string]string{}
        for _, arg := range strings.Fields(s) </span><span class="cov4" title="32">{
                m := strings.Split(arg, "=")
                switch len(m) </span>{
                case 2:<span class="cov4" title="27">
                        argMap[strings.ToUpper(m[0])] = m[1]</span>
                case 1:<span class="cov2" title="5">
                        argMap[strings.ToUpper(m[0])] = ""</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("failed to parse arg string: %q", arg)</span>
                }
        }
        <span class="cov5" title="73">return argMap, nil</span>
}

// HelloArgument parses helo argument
func HelloArgument(arg string) (string, error) <span class="cov5" title="60">{
        domain := arg
        if idx := strings.IndexRune(arg, ' '); idx &gt;= 0 </span><span class="cov0" title="0">{
                domain = arg[:idx]
        }</span>
        <span class="cov5" title="60">if domain == "" </span><span class="cov0" title="0">{
                return "", errors.New("invalid domain")
        }</span>
        <span class="cov5" title="60">return domain, nil</span>
}

// Parser parses command arguments defined in RFC 5321 section 4.1.2.
type Parser struct {
        S string
}

func (p *Parser) peekByte() (byte, bool) <span class="cov10" title="3063">{
        if len(p.S) == 0 </span><span class="cov4" title="24">{
                return 0, false
        }</span>
        <span class="cov9" title="3039">return p.S[0], true</span>
}

func (p *Parser) readByte() (byte, bool) <span class="cov9" title="1352">{
        ch, ok := p.peekByte()
        if ok </span><span class="cov9" title="1352">{
                p.S = p.S[1:]
        }</span>
        <span class="cov9" title="1352">return ch, ok</span>
}

func (p *Parser) acceptByte(ch byte) bool <span class="cov7" title="406">{
        got, ok := p.peekByte()
        if !ok || got != ch </span><span class="cov6" title="194">{
                return false
        }</span>
        <span class="cov7" title="212">p.readByte()
        return true</span>
}

func (p *Parser) expectByte(ch byte) error <span class="cov6" title="147">{
        if !p.acceptByte(ch) </span><span class="cov2" title="3">{
                if len(p.S) == 0 </span><span class="cov2" title="3">{
                        return fmt.Errorf("expected '%v', got EOF", string(ch))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("expected '%v', got '%v'", string(ch), string(p.S[0]))</span>
        }
        <span class="cov6" title="144">return nil</span>
}

// ReversePath parses a recipient.
func (p *Parser) ReversePath() (string, error) <span class="cov5" title="54">{
        if strings.HasPrefix(p.S, "&lt;&gt;") </span><span class="cov1" title="2">{
                p.S = strings.TrimPrefix(p.S, "&lt;&gt;")
                return "", nil
        }</span>
        <span class="cov5" title="52">return p.Path()</span>
}

// Path parses a recipient.
func (p *Parser) Path() (string, error) <span class="cov5" title="86">{
        hasBracket := p.acceptByte('&lt;')
        if p.acceptByte('@') </span><span class="cov0" title="0">{
                i := strings.IndexByte(p.S, ':')
                if i &lt; 0 </span><span class="cov0" title="0">{
                        return "", errors.New("malformed a-d-l")
                }</span>
                <span class="cov0" title="0">p.S = p.S[i+1:]</span>
        }
        <span class="cov5" title="86">mbox, err := p.Mailbox()
        if err != nil </span><span class="cov3" title="9">{
                return "", fmt.Errorf("in mailbox: %v", err)
        }</span>
        <span class="cov5" title="77">if hasBracket </span><span class="cov5" title="67">{
                if err := p.expectByte('&gt;'); err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
        }
        <span class="cov5" title="76">return mbox, nil</span>
}

// Mailbox parses a mailbox.
func (p *Parser) Mailbox() (string, error) <span class="cov6" title="87">{
        localPart, err := p.localPart()
        if err != nil </span><span class="cov2" title="4">{
                return "", fmt.Errorf("in local-part: %v", err)
        }</span> else<span class="cov5" title="83"> if localPart == "" </span><span class="cov2" title="3">{
                return "", errors.New("local-part is empty")
        }</span>

        <span class="cov5" title="80">if err := p.expectByte('@'); err != nil </span><span class="cov1" title="2">{
                return "", err
        }</span>

        <span class="cov5" title="78">var sb strings.Builder
        sb.WriteString(localPart)
        sb.WriteByte('@')

        for </span><span class="cov8" title="873">{
                ch, ok := p.peekByte()
                if !ok </span><span class="cov3" title="7">{
                        break</span>
                }
                <span class="cov8" title="866">if ch == ' ' || ch == '\t' || ch == '&gt;' </span><span class="cov5" title="71">{
                        break</span>
                }
                <span class="cov8" title="795">p.readByte()
                sb.WriteByte(ch)</span>
        }

        <span class="cov5" title="78">if strings.HasSuffix(sb.String(), "@") </span><span class="cov0" title="0">{
                return "", errors.New("domain is empty")
        }</span>

        <span class="cov5" title="78">return sb.String(), nil</span>
}

func (p *Parser) localPart() (string, error) <span class="cov6" title="87">{
        var sb strings.Builder

        if p.acceptByte('"') </span><span class="cov0" title="0">{ // quoted-string
                for </span><span class="cov0" title="0">{
                        ch, ok := p.readByte()
                        switch ch </span>{
                        case '\\':<span class="cov0" title="0">
                                ch, ok = p.readByte()</span>
                        case '"':<span class="cov0" title="0">
                                return sb.String(), nil</span>
                        }
                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                return "", errors.New("malformed quoted-string")
                        }</span>
                        <span class="cov0" title="0">sb.WriteByte(ch)</span>
                }
        } else<span class="cov6" title="87"> { // dot-string
                for </span><span class="cov7" title="432">{
                        ch, ok := p.peekByte()
                        if !ok </span><span class="cov2" title="5">{
                                return sb.String(), nil
                        }</span>
                        <span class="cov7" title="427">switch ch </span>{
                        case '@':<span class="cov5" title="78">
                                return sb.String(), nil</span>
                        case '(', ')', '&lt;', '&gt;', '[', ']', ':', ';', '\\', ',', '"', ' ', '\t':<span class="cov2" title="4">
                                return "", errors.New("malformed dot-string")</span>
                        }
                        <span class="cov7" title="345">p.readByte()
                        sb.WriteByte(ch)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package textsmtp

import (
        "bufio"
        "bytes"
        "io"

        "github.com/uponusolutions/go-smtp"
)

var crlfdot = []byte{'\r', '\n', '.'}

type dotReader struct {
        r     *bufio.Reader
        state int

        limited bool
        n       int64 // Maximum bytes remaining
}

// NewDotReader creates a new dot reader.
func NewDotReader(reader *bufio.Reader, maxMessageBytes int64) io.Reader <span class="cov6" title="4076">{
        dr := &amp;dotReader{
                r: reader,
        }

        if maxMessageBytes &gt; 0 </span><span class="cov2" title="6">{
                dr.limited = true
                dr.n = maxMessageBytes
        }</span>

        <span class="cov6" title="4076">return dr</span>
}

//go:inline
func noCrlfDotFound(err error, b []byte, c []byte) int <span class="cov9" title="588956">{
        if err == nil &amp;&amp; len(c) &gt; 1 &amp;&amp; c[len(c)-2] == '\r' &amp;&amp; c[len(c)-1] == '\n' </span><span class="cov6" title="5326">{
                // ends with \r\n, write everything before
                return copy(b, c[:len(c)-2])
        }</span> else<span class="cov9" title="583630"> if err == nil &amp;&amp; len(c) &gt; 0 &amp;&amp; c[len(c)-1] == '\r' </span><span class="cov5" title="1473">{
                // ends with \r, write everything before
                return copy(b, c[:len(c)-1])
        }</span>
        <span class="cov9" title="582157">return copy(b, c)</span>
}

// Read reads in some more bytes.
func (r *dotReader) Read(b []byte) (int, error) <span class="cov9" title="589165">{
        // Run data through a simple state machine to
        // elide leading dots and detect End-of-Data (&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;) line.
        const (
                stateBeginLine = iota // beginning of line; initial state; must be zero
                stateCR               // wrote \r
                stateEOF              // reached .\r\n end marker line
        )

        if r.limited </span><span class="cov2" title="13">{
                if r.n &lt;= 0 </span><span class="cov1" title="2">{
                        return 0, smtp.ErrDataTooLarge
                }</span>
                <span class="cov2" title="11">if int64(len(b)) &gt; r.n </span><span class="cov2" title="8">{
                        b = b[0:r.n]
                }</span>
        }

        <span class="cov9" title="589163">var n int       // data written to b
        var skipped int // how many

        // IMPORTANT: We cannot wait on read, because no EOL returns
        if r.r.Buffered() &lt; 5 </span><span class="cov9" title="518087">{
                _, _ = r.r.Peek(5)
        }</span>

        // min 5, max buffer size, default len(b)
        <span class="cov9" title="589163">c, err := r.r.Peek(max(min(len(b), r.r.Buffered()), 5))

        // write \n
        if r.state == stateCR </span><span class="cov1" title="4">{
                b[0] = '\n'
                n++
                skipped += 2
                r.state = stateBeginLine
                if c[3] == '\r' &amp;&amp; c[4] == '\n' </span><span class="cov1" title="2">{
                        r.state = stateEOF
                        skipped += 2 // skip .\n\r
                }</span> else<span class="cov1" title="2"> {
                        b = b[1:]
                        c = c[3:]
                }</span>
        }

        <span class="cov9" title="589163">if r.state != stateEOF </span><span class="cov9" title="589160">{
                for </span><span class="cov10" title="621544">{
                        i := bytes.Index(c, crlfdot)

                        // no full \r\n. found
                        if i == -1 </span><span class="cov9" title="588956">{
                                n += noCrlfDotFound(err, b, c)
                                break</span>
                        }

                        <span class="cov8" title="32588">if len(c)-1 &lt; i+4 </span><span class="cov4" title="180">{
                                // i is \r, \n.\r\n needs to be accessible

                                if err != nil </span><span class="cov1" title="2">{
                                        // no more data, just read to the end
                                        n += copy(b, c[:i+2])
                                        skipped++
                                }</span> else<span class="cov4" title="178"> if i &gt; 0 </span><span class="cov4" title="178">{
                                        // not enough bytes to check for \r\n.\r\n, write everything before
                                        n += copy(b, c[:i])
                                }</span>

                                <span class="cov4" title="180">break</span>
                        }

                        <span class="cov8" title="32408">p := copy(b, c[:i+2])
                        n += p

                        // b was to small
                        if p &lt; i+2 </span><span class="cov2" title="5">{
                                // we only wrote \r
                                if i+2-p == 1 </span><span class="cov2" title="5">{
                                        r.state = stateCR // next time we want to write \n
                                        skipped--         // prevent \r from being discarded
                                }</span>
                                <span class="cov2" title="5">break</span>
                        }

                        // the end \r\n.\n\r
                        <span class="cov8" title="32403">if c[i+3] == '\r' &amp;&amp; c[i+4] == '\n' </span><span class="cov2" title="19">{
                                r.state = stateEOF
                                skipped += 3 // skip .\r\n
                                break</span>
                        }

                        <span class="cov8" title="32384">skipped++ // . isn't written
                        b = b[i+2:]
                        c = c[i+3:]</span>
                }
        }

        // n + skipped is always smaller then what was peeked, so it is guaranteed to work
        <span class="cov9" title="589163">_, _ = r.r.Discard(n + skipped)

        if err == io.EOF &amp;&amp; r.state != stateEOF </span><span class="cov6" title="4055">{
                err = io.ErrUnexpectedEOF
        }</span> else<span class="cov9" title="585108"> if err == nil &amp;&amp; r.state == stateEOF </span><span class="cov3" title="22">{
                err = io.EOF
        }</span>

        <span class="cov9" title="589163">if r.limited </span><span class="cov2" title="11">{
                r.n -= int64(n)
        }</span>

        <span class="cov9" title="589163">return n, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Based on the modifications from
// https://github.com/go-textproto/textproto/blob/v0/writer.go

package textsmtp

import (
        "bufio"
        "bytes"
        "io"
)

var (
        crnl    = []byte{'\r', '\n'}
        dotcrnl = []byte{'.', '\r', '\n'}
)

// NewDotWriter returns a writer that can be used to write a dot-encoding to w.
// It takes care of inserting leading dots when necessary,
// translating line-ending \n into \r\n, and adding the final .\r\n line
// when the DotWriter is closed. The caller should close the
// DotWriter before the next call to a method on w.
//
// See the documentation for Reader's DotReader method for details about dot-encoding.
func NewDotWriter(writer *bufio.Writer) io.WriteCloser <span class="cov6" title="8104">{
        return &amp;dotWriter{
                W: writer,
        }
}</span>

type dotWriter struct {
        W     *bufio.Writer
        state int
}

const (
        wstateBegin     = iota // starting state
        wstateBeginLine        // beginning of line
        wstateCR               // wrote \r (possibly at end of line)
        wstateData             // writing data in middle of line
)

func (d *dotWriter) Write(b []byte) (n int, err error) <span class="cov9" title="1221416">{
        var (
                i    int
                p    []byte
                pLen int
                bw   = d.W
        )
        for len(b) &gt; 0 </span><span class="cov10" title="2804204">{
                i = bytes.IndexByte(b, '\n')
                if i &gt;= 0 </span><span class="cov9" title="1586447">{
                        p, b = b[:i+1], b[i+1:]
                }</span> else<span class="cov9" title="1217757"> {
                        p, b = b, nil
                }</span>
                <span class="cov10" title="2804204">pLen = len(p)
                if d.state == wstateBeginLine &amp;&amp; p[0] == '.' </span><span class="cov7" title="24300">{
                        err = bw.WriteByte('.')
                        if err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                }

                <span class="cov10" title="2804204">if b == nil </span><span class="cov9" title="1217757">{
                        // no end of line found in p
                        if p[pLen-1] == '\r' </span><span class="cov5" title="1493">{
                                // p ends with \r
                                d.state = wstateCR
                        }</span> else<span class="cov9" title="1216264"> {
                                // just write it down
                                d.state = wstateData
                        }</span>

                        <span class="cov9" title="1217757">if _, err = bw.Write(p); err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                } else<span class="cov9" title="1586447"> if d.state == wstateCR &amp;&amp; pLen == 1 </span><span class="cov5" title="1491">{
                        // if b isn't nil and pLen is 1, then it must be a \n
                        // as \r was send before, just write crnl
                        d.state = wstateBeginLine
                        if err = bw.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                } else<span class="cov9" title="1584956"> {
                        // line is ending
                        d.state = wstateBeginLine
                        if pLen &gt;= 2 &amp;&amp; p[pLen-2] == '\r' </span><span class="cov9" title="791734">{
                                // fastpath if line ending is correct \r\n
                                if _, err = bw.Write(p); err != nil </span><span class="cov0" title="0">{
                                        return n, err
                                }</span>
                        } else<span class="cov9" title="793222"> {
                                // data + crnl
                                if _, err = bw.Write(p[:pLen-1]); err != nil </span><span class="cov0" title="0">{
                                        return n, err
                                }</span>
                                <span class="cov9" title="793222">if _, err = bw.Write(crnl); err != nil </span><span class="cov0" title="0">{
                                        return n, err
                                }</span>
                        }
                }

                <span class="cov10" title="2804204">n += pLen</span>
        }
        <span class="cov9" title="1221416">return n, err</span>
}

func (d *dotWriter) Close() error <span class="cov6" title="8104">{
        bw := d.W
        switch d.state </span>{
        default:<span class="cov6" title="8102">
                if err := bw.WriteByte('\r'); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="8102">fallthrough</span>
        case wstateCR:<span class="cov6" title="8104">
                // normally \r gets ignored if no \n follows, but at closing we just take it as a line break
                // same behavior as original textproto
                if err := bw.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="8104">fallthrough</span>
        case wstateBeginLine:<span class="cov6" title="8104">
                if _, err := bw.Write(dotcrnl); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="8104">return bw.Flush()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package textsmtp

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "net/textproto"
        "strconv"
        "strings"
)

// Textproto is used as a wrapper around a connection to read and write to it
type Textproto struct {
        R                  *bufio.Reader
        W                  *bufio.Writer
        conn               io.ReadWriteCloser
        maxLineLength      int
        lineLengthExceeded bool
        textproto.Pipeline
}

// NewTextproto creates a new connection wrapper.
func NewTextproto(
        conn io.ReadWriteCloser,
        readerSize int,
        writerSize int,
        maxLineLength int,
) *Textproto <span class="cov7" title="94">{
        if readerSize == 0 </span><span class="cov6" title="59">{
                readerSize = 4096 // default
        }</span>

        <span class="cov7" title="94">if writerSize == 0 </span><span class="cov6" title="59">{
                writerSize = 4096 // default
        }</span>

        <span class="cov7" title="94">return &amp;Textproto{
                R:                  bufio.NewReaderSize(conn, readerSize),
                W:                  bufio.NewWriterSize(conn, writerSize),
                conn:               conn,
                maxLineLength:      maxLineLength,
                lineLengthExceeded: false,
        }</span>
}

// ErrTooLongLine occurs if the smtp line is too long.
var ErrTooLongLine = errors.New("smtp: too long a line in input stream")

// Cmd is a convenience method that sends a command after
// waiting its turn in the pipeline. The command text is the
// result of formatting format with args and appending \r\n.
// Cmd returns the id of the command, for use with StartResponse and EndResponse.
//
// For example, a client might run a HELP command that returns a dot-body
// by using:
//
//        id, err := c.Cmd("HELP")
//        if err != nil {
//                return nil, err
//        }
//
//        c.StartResponse(id)
//        defer c.EndResponse(id)
//
//        if _, _, err = c.ReadCodeLine(110); err != nil {
//                return nil, err
//        }
//        text, err := c.ReadDotBytes()
//        if err != nil {
//                return nil, err
//        }
//        return c.ReadCodeLine(250)
func (t *Textproto) Cmd(format string, args ...any) (id uint, err error) <span class="cov7" title="84">{
        id = t.Next()
        t.StartRequest(id)
        err = t.PrintfLineAndFlush(format, args...)
        t.EndRequest(id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov7" title="84">return id, nil</span>
}

// PrintfLine writes the formatted output followed by \r\n.
func (t *Textproto) PrintfLine(format string, args ...any) error <span class="cov10" title="723">{
        if _, err := fmt.Fprintf(t.W, format, args...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="723">_, err := t.W.Write(crnl)
        return err</span>
}

// PrintfLineAndFlush writes the formatted output followed by \r\n anf flushes.
func (t *Textproto) PrintfLineAndFlush(format string, args ...any) error <span class="cov9" title="421">{
        err := t.PrintfLine(format, args...)
        if err == nil </span><span class="cov9" title="421">{
                err = t.W.Flush()
        }</span>
        <span class="cov9" title="421">return err</span>
}

// ReadResponse reads a multi-line response of the form:
//
//        code-message line 1
//        code-message line 2
//        ...
//        code message line n
//
// where code is a three-digit status code. The first line starts with the
// code and a hyphen. The response is terminated by a line that starts
// with the same code followed by a space. Each line in message is
// separated by a newline (\n).
//
// See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for
// details of another form of response accepted:
//
//        code-message line 1
//        message line 2
//        ...
//        code message line n
//
// If the prefix of the status does not match the digits in expectCode,
// ReadResponse returns with err set to &amp;Error{code, message}.
// For example, if expectCode is 31, an error will be returned if
// the status is not in the range [310,319].
//
// An expectCode &lt;= 0 disables the check of the status code.
func (t *Textproto) ReadResponse(expectCode int) (code int, message string, err error) <span class="cov7" title="115">{
        code, continued, message, err := t.readCodeLine(expectCode)
        multi := continued
        for continued </span><span class="cov6" title="65">{
                line, err := t.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", err
                }</span>

                <span class="cov6" title="65">var code2 int
                var moreMessage string
                code2, continued, moreMessage, err = parseCodeLine(line, 0)
                if err != nil || code2 != code </span><span class="cov1" title="2">{
                        message += "\n" + strings.TrimRight(line, "\r\n")
                        continued = true
                        continue</span>
                }
                <span class="cov6" title="63">message += "\n" + moreMessage</span>
        }
        <span class="cov7" title="115">if err != nil &amp;&amp; multi &amp;&amp; message != "" </span><span class="cov1" title="2">{
                // replace one line error message with all lines (full message)
                err = &amp;textproto.Error{Code: code, Msg: message}
        }</span>
        <span class="cov7" title="115">return code, message, err</span>
}

// ReadCodeLine reads a code line.
func (t *Textproto) ReadCodeLine(expectCode int) (int, string, error) <span class="cov2" title="4">{
        code, continued, message, err := t.readCodeLine(expectCode)
        if err == nil &amp;&amp; continued </span><span class="cov0" title="0">{
                err = textproto.ProtocolError("unexpected multi-line response: " + message)
        }</span>
        <span class="cov2" title="4">return code, message, err</span>
}

func (t *Textproto) readCodeLine(expectCode int) (code int, continued bool, message string, err error) <span class="cov7" title="119">{
        line, err := t.ReadLine()
        if err != nil </span><span class="cov2" title="4">{
                return code, continued, message, err
        }</span>
        <span class="cov7" title="115">return parseCodeLine(line, expectCode)</span>
}

func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) <span class="cov8" title="180">{
        if len(line) &lt; 4 || line[3] != ' ' &amp;&amp; line[3] != '-' </span><span class="cov1" title="2">{
                err = textproto.ProtocolError("short response: " + line)
                return code, continued, message, err
        }</span>
        <span class="cov8" title="178">continued = line[3] == '-'
        code, err = strconv.Atoi(line[0:3])
        if err != nil || code &lt; 100 </span><span class="cov0" title="0">{
                err = textproto.ProtocolError("invalid response code: " + line)
                return code, continued, message, err
        }</span>
        <span class="cov8" title="178">message = line[4:]
        if 1 &lt;= expectCode &amp;&amp; expectCode &lt; 10 &amp;&amp; code/100 != expectCode ||
                10 &lt;= expectCode &amp;&amp; expectCode &lt; 100 &amp;&amp; code/10 != expectCode ||
                100 &lt;= expectCode &amp;&amp; expectCode &lt; 1000 &amp;&amp; code != expectCode </span><span class="cov5" title="27">{
                err = &amp;textproto.Error{Code: code, Msg: message}
        }</span>
        <span class="cov8" title="178">return code, continued, message, err</span>
}

// ReadLine reads a single line from r,
// eliding the final \n or \r\n from the returned string.
func (t *Textproto) ReadLine() (string, error) <span class="cov9" title="500">{
        line, err := t.readLineSlice()
        return string(line), err
}</span>

func (t *Textproto) readLineSlice() ([]byte, error) <span class="cov9" title="500">{
        // If the line limit was exceeded once, the connection shouldn't be used anymore.
        if t.lineLengthExceeded </span><span class="cov1" title="1">{
                return nil, ErrTooLongLine
        }</span>

        <span class="cov9" title="499">var line []byte
        for </span><span class="cov9" title="499">{
                l, more, err := t.R.ReadLine()
                if err != nil </span><span class="cov6" title="53">{
                        return nil, err
                }</span>

                <span class="cov9" title="444">if t.maxLineLength &gt; 0 &amp;&amp; len(l)+len(line) &gt; t.maxLineLength </span><span class="cov2" title="3">{
                        t.lineLengthExceeded = true
                        return nil, ErrTooLongLine
                }</span>

                // Avoid the copy if the first call produced a full line.
                <span class="cov9" title="441">if line == nil &amp;&amp; !more </span><span class="cov9" title="441">{
                        return l, nil
                }</span>
                <span class="cov0" title="0">line = append(line, l...)
                if !more </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return line, nil</span>
}

// Replace conn.
func (t *Textproto) Replace(conn io.ReadWriteCloser) <span class="cov2" title="3">{
        t.conn = conn
        t.R.Reset(t.conn)
        t.W.Reset(t.conn)
}</span>

// Close closes the connection.
func (t *Textproto) Close() error <span class="cov5" title="25">{
        return t.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package textsmtp

import (
        "errors"

        "github.com/uponusolutions/go-smtp"
)

// IsPrintableASCII checks if string contains only printable ascii.
func IsPrintableASCII(val string) bool <span class="cov4" title="6">{
        for _, ch := range val </span><span class="cov10" title="66">{
                if ch &lt; ' ' || '~' &lt; ch </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov4" title="6">return true</span>
}

// CheckNotifySet checks if a DSNNotify array isn't malformed.
func CheckNotifySet(values []smtp.DSNNotify) error <span class="cov5" title="7">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return errors.New("malformed NOTIFY parameter value")
        }</span>

        <span class="cov5" title="7">seen := map[smtp.DSNNotify]struct{}{}
        for _, val := range values </span><span class="cov5" title="10">{
                switch val </span>{
                case smtp.DSNNotifyNever, smtp.DSNNotifyDelayed, smtp.DSNNotifyFailure, smtp.DSNNotifySuccess:<span class="cov5" title="10">
                        if _, ok := seen[val]; ok </span><span class="cov0" title="0">{
                                return errors.New("malformed NOTIFY parameter value")
                        }</span>
                default:<span class="cov0" title="0">
                        return errors.New("malformed NOTIFY parameter value")</span>
                }
                <span class="cov5" title="10">seen[val] = struct{}{}</span>
        }
        <span class="cov5" title="7">if _, ok := seen[smtp.DSNNotifyNever]; ok &amp;&amp; len(seen) &gt; 1 </span><span class="cov0" title="0">{
                return errors.New("malformed NOTIFY parameter value")
        }</span>

        <span class="cov5" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package smtp

import (
        "regexp"
)

/*
   https://github.com/moisseev/rspamd/blob/master/rules/misc.lua

    Detect PRVS/BATV addresses to avoid FORGED_SENDER
    https://en.wikipedia.org/wiki/Bounce_Address_Tag_Validation

    Signature syntax:
        prvs=TAG=USER@example.com       BATV draft (https://tools.ietf.org/html/draft-levine-smtp-batv-01)
        prvs=USER=TAG@example.com
        btv1==TAG==USER@example.com     Barracuda appliance
        msprvs1=TAG=USER@example.com    Sparkpost email delivery service
*/

const (
        regexpBATV = "^(?:(?:prvs|msprvs1)=[^=]+=|btv1==[^=]+==)([^@]+@(?:[^@]+))$"
        regexpSRS  = "^([^+]+)\\+SRS=[^=]+=[^=]+=[^=]+=[^@]+@([^@]+)$"
)

var (
        compiledRegexpBATV = regexp.MustCompile(regexpBATV)
        compiledRegexpSRS  = regexp.MustCompile(regexpSRS)
)

// ParseBATV parses src to extract a BATV address.
// When BATV extration is not possible/needed src is returned.
func ParseBATV(src string) string <span class="cov10" title="5">{
        res := compiledRegexpBATV.FindStringSubmatch(src)
        if len(res) == 2 </span><span class="cov8" title="4">{
                return res[1]
        }</span>
        <span class="cov1" title="1">return src</span>
}

// ParseSRS parses src to extract the forwarding sender from SRS (Exchange Online).
// When SRS extration is not possible/needed src is returned.
func ParseSRS(src string) string <span class="cov4" title="2">{
        res := compiledRegexpSRS.FindStringSubmatch(src)
        if len(res) == 3 </span><span class="cov1" title="1">{
                return res[1] + "@" + res[2]
        }</span>
        <span class="cov1" title="1">return src</span>
}

// ParseSender combines ParseSRS and ParseBATV.
func ParseSender(src string) string <span class="cov0" title="0">{
        return ParseBATV(ParseSRS(src))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "io"
        "log/slog"

        "github.com/uponusolutions/go-sasl"
        "github.com/uponusolutions/go-smtp"
)

// Backend is a SMTP server backend.
type Backend interface {
        NewSession(ctx context.Context, c *Conn) (context.Context, Session, error)
}

// BackendFunc is an adapter to allow the use of an ordinary function as a
// Backend.
type BackendFunc func(ctx context.Context, c *Conn) (context.Context, Session, error)

// NewSession calls f(c).
// The returning context is used in the session.
func (f BackendFunc) NewSession(ctx context.Context, c *Conn) (context.Context, Session, error) <span class="cov0" title="0">{
        return f(ctx, c)
}</span>

// Session is used by servers to respond to an SMTP client.
//
// The methods are called when the remote client issues the matching command.
type Session interface {
        // Discard currently processed message.
        // The returning context replaces the context used in the current session.
        // Upgrade is true when the reset is called after a tls upgrade.
        Reset(ctx context.Context, upgrade bool) (context.Context, error)

        // Free all resources associated with session.
        // Error is set if an error occurred during session or connection.
        // Close is always called after the session is done.
        Close(ctx context.Context, err error)

        // Returns logger to use when an error occurs inside a session.
        // If no logger is returned the default *slog.Logger is used.
        Logger(ctx context.Context) *slog.Logger

        // Set return path for currently processed message.
        Mail(ctx context.Context, from string, opts *smtp.MailOptions) error

        // Add recipient for currently processed message.
        Rcpt(ctx context.Context, to string, opts *smtp.RcptOptions) error

        // Verify checks the validity of an email address on the server.
        // If error is nil then smtp code 252 is send
        // if error is smtp status then the smtp status is send
        // else internal server error is returned and connection is closed
        Verify(ctx context.Context, addr string, opts *smtp.VrfyOptions) error

        // Set currently processed message contents and send it.
        // If r is called then the data must be consumed completely before returning.
        // The queuedid must not be unique.
        Data(ctx context.Context, r func() io.Reader) (queueid string, err error)

        // AuthMechanisms returns valid auth mechanism.
        // Nil or an empty list means no authentication mechanism is allowed.
        AuthMechanisms(ctx context.Context) []string

        // Auth returns a matching sasl server for the given mech.
        Auth(ctx context.Context, mech string) (sasl.Server, error)

        // STARTTLS returns a valid *tls.Config.
        // Is called with the default tls config and the returned tls config is used in the tls upgrade.
        // If the tls.Config is nil or an error is returned, the tls upgrade is aborted and the connection closed.
        // The *tls.Config received must not be changed.
        STARTTLS(ctx context.Context, tls *tls.Config) (*tls.Config, error)
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package server

import (
        "io"
        "strconv"
        "strings"

        "github.com/uponusolutions/go-smtp"
)

type bdat struct {
        size            int64
        last            bool
        bytesReceived   int64
        maxMessageBytes int64
        input           io.Reader
        chunk           io.Reader
        nextCommand     func() (string, string, error)
}

func bdatArg(arg string) (int64, bool, error) <span class="cov7" title="13">{
        args := strings.Fields(arg)
        if len(args) == 0 </span><span class="cov0" title="0">{
                return 0, true, smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Missing chunk size argument")
        }</span>
        <span class="cov7" title="13">if len(args) &gt; 2 </span><span class="cov0" title="0">{
                return 0, true, smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Too many arguments")
        }</span>

        <span class="cov7" title="13">last := false
        if len(args) == 2 </span><span class="cov4" title="4">{
                if !strings.EqualFold(args[1], "LAST") </span><span class="cov0" title="0">{
                        return 0, true, smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unknown BDAT argument")
                }</span>
                <span class="cov4" title="4">last = true</span>
        }

        // ParseUint instead of Atoi so we will not accept negative values.
        <span class="cov7" title="13">size, err := strconv.ParseUint(args[0], 10, 32)
        if err != nil || (size == 0 &amp;&amp; !last) </span><span class="cov0" title="0">{
                return 0, true, smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Malformed size argument")
        }</span>

        <span class="cov7" title="13">return int64(size), last, nil</span>
}

func (d *bdat) Read(b []byte) (int, error) <span class="cov10" title="35">{
        if d.size == 0 </span><span class="cov8" title="16">{
                if d.last </span><span class="cov5" title="6">{
                        return 0, io.EOF
                }</span>

                <span class="cov6" title="10">d.chunk = nil

                cmd, arg, err := d.nextCommand()
                if err != nil </span><span class="cov4" title="4">{
                        if err == io.EOF </span><span class="cov4" title="4">{
                                return 0, smtp.ErrConnection
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                <span class="cov5" title="6">switch cmd </span>{
                case "RSET":<span class="cov1" title="1">
                        return 0, smtp.Reset</span>
                case "QUIT":<span class="cov1" title="1">
                        return 0, smtp.Quit</span>
                case "BDAT":<span class="cov4" title="4">
                        d.size, d.last, err = bdatArg(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov4" title="4">if d.last &amp;&amp; d.size == 0 </span><span class="cov0" title="0">{
                                return 0, io.EOF
                        }</span>
                default:<span class="cov0" title="0">
                        return 0, smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "BDAT command expected")</span>
                }
        }

        <span class="cov8" title="23">if d.maxMessageBytes != 0 &amp;&amp; d.bytesReceived+d.size &gt; d.maxMessageBytes </span><span class="cov2" title="2">{
                return 0, smtp.NewStatus(552, smtp.EnhancedCode{5, 3, 4}, "Max message size exceeded")
        }</span>

        <span class="cov8" title="21">if d.chunk == nil </span><span class="cov7" title="12">{
                d.chunk = io.LimitReader(d.input, int64(d.size))
        }</span>

        <span class="cov8" title="21">n, err := d.chunk.Read(b)
        d.bytesReceived += int64(n)
        d.size -= int64(n)

        // this isn't the end
        if err == io.EOF &amp;&amp; !d.last </span><span class="cov2" title="2">{
                // stream broke in the middle
                if d.size &gt; 0 </span><span class="cov2" title="2">{
                        err = smtp.ErrConnection
                }</span> else<span class="cov0" title="0"> {
                        err = nil
                }</span>
        }

        <span class="cov8" title="21">return n, err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net"
        "slices"
        "strconv"
        "strings"
        "time"

        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/internal/parse"
        "github.com/uponusolutions/go-smtp/internal/textsmtp"
)

type state int32

const (
        stateInit                    state = 0
        stateUpgrade                 state = 1
        stateEnforceAuthentication   state = 2
        stateEnforceSecureConnection state = 3
        stateGreeted                 state = 4
        stateMail                    state = 5
)

// Conn is a connection inside a smtp server.
type Conn struct {
        ctx context.Context

        conn net.Conn

        state state

        text   *textsmtp.Textproto
        server *Server

        session    Session
        binarymime bool

        helo       string   // set in helo / ehlo
        mechanisms []string // seh in helo / ehlo
        recipients int      // count recipients
        didAuth    bool
}

// run loops until an error occurs (quit for example)
func (c *Conn) run() error <span class="cov6" title="59">{
        c.greet()

        for </span><span class="cov8" title="276">{
                cmd, arg, err := c.nextCommand()
                if err != nil </span><span class="cov6" title="54">{
                        return err
                }</span>

                <span class="cov8" title="220">err = c.handle(cmd, arg)
                if err != nil </span><span class="cov8" title="210">{
                        // if error is a smtp status it isn't necessary to close the connection
                        if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov8" title="210">{
                                // Service closing transmission channel, after quit
                                if smtpErr.Code == 221 </span><span class="cov1" title="2">{
                                        return smtpErr
                                }</span>

                                // ToDo: close connection on repeated errors (e.g. authentication tries)

                                <span class="cov8" title="208">c.writeStatus(smtpErr)
                                continue</span>
                        }

                        <span class="cov0" title="0">return err</span>
                }
        }
}

func (c *Conn) nextCommand() (cmd string, arg string, err error) <span class="cov8" title="282">{
        line, err := c.readLine()
        if err != nil </span><span class="cov6" title="52">{
                return "", "", err
        }</span>
        <span class="cov8" title="228">return parse.Cmd(line)</span>
}

// Commands are dispatched to the appropriate handler functions.
func (c *Conn) handle(cmd string, arg string) error <span class="cov8" title="220">{
        if cmd == "" </span><span class="cov0" title="0">{
                return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 2}, "Error: bad syntax")
        }</span>
        <span class="cov8" title="220">cmd = strings.ToUpper(cmd)

        switch c.state </span>{
        case stateInit:<span class="cov6" title="58">
                fallthrough</span>
        case stateUpgrade:<span class="cov6" title="60">
                return c.handleStateInit(cmd, arg)</span>
        case stateEnforceSecureConnection:<span class="cov2" title="3">
                return c.handleStateEnforceSecureConnection(cmd, arg)</span>
        case stateEnforceAuthentication:<span class="cov3" title="7">
                return c.handleStateEnforceAuthentication(cmd, arg)</span>
        case stateGreeted:<span class="cov7" title="91">
                return c.handleStateGreeted(cmd, arg)</span>
        case stateMail:<span class="cov6" title="59">
                return c.handleStateMail(cmd, arg)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unsupported state %d, how?", c.state)</span>
}

func (c *Conn) handleStateInit(cmd string, arg string) error <span class="cov6" title="60">{
        switch cmd </span>{
        case "HELO", "EHLO":<span class="cov6" title="60">
                return c.handleGreet(cmd == "EHLO", arg)</span>
        case "NOOP":<span class="cov0" title="0">
                return smtp.Noop</span>
        case "VRFY":<span class="cov0" title="0">
                return c.handleVrfy(arg)</span>
        case "RSET":<span class="cov0" title="0"> // Reset session
                return c.handleRSET()</span>
        case "QUIT":<span class="cov0" title="0">
                return smtp.Quit</span>
        default:<span class="cov0" title="0">
                return c.commandUnknown(cmd)</span>
        }
}

func (c *Conn) handleStateEnforceAuthentication(cmd string, arg string) error <span class="cov3" title="7">{
        switch cmd </span>{
        case "HELO", "EHLO":<span class="cov0" title="0">
                return c.handleGreet(cmd == "EHLO", arg)</span>
        case "NOOP":<span class="cov0" title="0">
                return smtp.Noop</span>
        case "VRFY":<span class="cov0" title="0">
                return c.handleVrfy(arg)</span>
        case "RSET":<span class="cov0" title="0"> // Reset session
                return c.handleRSET()</span>
        case "QUIT":<span class="cov0" title="0">
                return smtp.Quit</span>
        case "AUTH":<span class="cov2" title="4">
                // there is always a mechanism, as it is an enforce authentication precondition
                return c.handleAuth(arg)</span>
        case "STARTTLS":<span class="cov1" title="1">
                return c.handleStartTLS()</span>
        default:<span class="cov1" title="2">
                return smtp.NewStatus(530, smtp.EnhancedCode{5, 7, 0}, "Authentication required")</span>
        }
}

func (c *Conn) handleStateGreeted(cmd string, arg string) error <span class="cov7" title="91">{
        switch cmd </span>{
        case "HELO", "EHLO":<span class="cov0" title="0">
                return c.handleGreet(cmd == "EHLO", arg)</span>
        case "MAIL":<span class="cov6" title="42">
                return c.handleMail(arg)</span>
        case "NOOP":<span class="cov1" title="2">
                return smtp.Noop</span>
        case "VRFY":<span class="cov2" title="3">
                return c.handleVrfy(arg)</span>
        case "RSET":<span class="cov1" title="1"> // Reset session
                return c.handleRSET()</span>
        case "QUIT":<span class="cov1" title="2">
                return smtp.Quit</span>
        case "AUTH":<span class="cov5" title="38">
                if len(c.mechanisms) &gt; 0 </span><span class="cov5" title="37">{
                        return c.handleAuth(arg)
                }</span>
                <span class="cov1" title="1">return smtp.ErrAuthUnsupported</span>
        case "STARTTLS":<span class="cov0" title="0">
                return c.handleStartTLS()</span>
        default:<span class="cov2" title="3">
                return c.commandUnknown(cmd)</span>
        }
}

func (c *Conn) handleStateMail(cmd string, arg string) error <span class="cov6" title="59">{
        switch cmd </span>{
        case "HELO", "EHLO":<span class="cov0" title="0">
                return c.handleGreet(cmd == "EHLO", arg)</span>
        case "RCPT":<span class="cov5" title="31">
                return c.handleRcpt(arg)</span>
        case "NOOP":<span class="cov0" title="0">
                return smtp.Noop</span>
        case "VRFY":<span class="cov0" title="0">
                return c.handleVrfy(arg)</span>
        case "RSET":<span class="cov0" title="0"> // Reset session
                return c.handleRSET()</span>
        case "BDAT":<span class="cov3" title="9">
                if !c.server.enableCHUNKING </span><span class="cov0" title="0">{
                        return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "CHUNKING is not implemented")
                }</span>
                <span class="cov3" title="9">return c.handleBdat(arg)</span>
        case "DATA":<span class="cov4" title="17">
                return c.handleData(arg)</span>
        case "QUIT":<span class="cov0" title="0">
                return smtp.Quit</span>
        case "STARTTLS":<span class="cov0" title="0">
                return c.handleStartTLS()</span>
        default:<span class="cov1" title="2">
                return c.commandUnknown(cmd)</span>
        }
}

func (c *Conn) handleStateEnforceSecureConnection(cmd string, arg string) error <span class="cov2" title="3">{
        switch cmd </span>{
        case "HELO", "EHLO":<span class="cov0" title="0">
                return c.handleGreet(cmd == "EHLO", arg)</span>
        case "NOOP":<span class="cov0" title="0">
                return smtp.Noop</span>
        case "VRFY":<span class="cov0" title="0">
                return c.handleVrfy(arg)</span>
        case "STARTTLS":<span class="cov1" title="1">
                return c.handleStartTLS()</span>
        case "QUIT":<span class="cov0" title="0">
                return smtp.Quit</span>
        default:<span class="cov1" title="2">
                return smtp.NewStatus(530, smtp.EnhancedCode{5, 7, 0}, "Must issue a STARTTLS command first")</span>
        }
}

func (c *Conn) commandUnknown(cmd string) *smtp.Status <span class="cov3" title="5">{
        return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 1}, fmt.Sprintf("%s command unknown, state %d", cmd, c.state))
}</span>

// Server returns the server this connection comes from.
func (c *Conn) Server() *Server <span class="cov0" title="0">{
        return c.server
}</span>

// Close closes the connection.
func (c *Conn) Close(err error) <span class="cov6" title="57">{
        c.logger().DebugContext(c.ctx, "connection is closing")

        closeErr := c.conn.Close()
        if closeErr != nil </span><span class="cov5" title="26">{
                if err == nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span> else<span class="cov5" title="26"> {
                        err = errors.Join(err, closeErr)
                }</span>
        }

        <span class="cov6" title="57">if err != nil </span><span class="cov6" title="55">{
                c.logger().ErrorContext(c.ctx, "close error", slog.Any("err", err))
        }</span>

        <span class="cov6" title="57">if c.session != nil </span><span class="cov6" title="57">{
                c.session.Close(c.ctx, err)
                c.session = nil
        }</span>
}

// TLSConnectionState returns the connection's TLS connection state.
// Zero values are returned if the connection doesn't use TLS.
func (c *Conn) TLSConnectionState() (tls.ConnectionState, bool) <span class="cov1" title="2">{
        tc, ok := c.conn.(*tls.Conn)
        if !ok </span><span class="cov1" title="2">{
                return tls.ConnectionState{}, ok
        }</span>
        <span class="cov0" title="0">return tc.ConnectionState(), true</span>
}

// IsTLS returns if the connection is encrypted by tls.
func (c *Conn) IsTLS() bool <span class="cov6" title="62">{
        _, ok := c.conn.(*tls.Conn)
        return ok
}</span>

// Hostname returns the name of the connected client.
func (c *Conn) Hostname() string <span class="cov0" title="0">{
        return c.helo
}</span>

// Mechanisms returns the allowed auth mechanism for this connection.
func (c *Conn) Mechanisms() []string <span class="cov0" title="0">{
        return c.mechanisms
}</span>

// Conn returns the connection.
func (c *Conn) Conn() net.Conn <span class="cov0" title="0">{
        return c.conn
}</span>

func (c *Conn) handleRSET() error <span class="cov1" title="1">{
        err := c.reset()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">c.writeStatus(smtp.Reset)
        return nil</span>
}

// GREET state -&gt; waiting for HELO
func (c *Conn) handleGreet(enhanced bool, arg string) error <span class="cov6" title="60">{
        domain, err := parse.HelloArgument(arg)
        if err != nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Domain/address argument required for HELO")
        }</span>
        // c.helo is populated before NewSession so
        // NewSession can access it via Conn.Hostname.
        <span class="cov6" title="60">c.helo = domain

        // RFC 5321: "An EHLO command MAY be issued by a client later in the session"
        // RFC 5321: "... the SMTP server MUST clear all buffers
        // and reset the state exactly as if a RSET command has been issued."
        if c.state != stateInit &amp;&amp; c.state != stateEnforceSecureConnection &amp;&amp; c.state != stateEnforceAuthentication </span><span class="cov1" title="2">{
                err := c.reset()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="60">if c.server.enforceSecureConnection &amp;&amp; !c.IsTLS() </span><span class="cov2" title="3">{
                c.state = stateEnforceSecureConnection
        }</span> else<span class="cov6" title="57"> if c.server.enforceAuthentication </span><span class="cov2" title="4">{
                c.state = stateEnforceAuthentication
        }</span> else<span class="cov6" title="53"> {
                c.state = stateGreeted
        }</span>

        <span class="cov6" title="60">if !enhanced </span><span class="cov2" title="3">{
                return smtp.NewStatus(250, smtp.EnhancedCode{2, 0, 0}, fmt.Sprintf("Hello %s", domain))
        }</span>

        <span class="cov6" title="57">caps := strings.Builder{}
        caps.Grow(512)

        caps.WriteString("Hello ")
        caps.WriteString(domain)

        caps.WriteString("\nPIPELINING\n8BITMIME\nENHANCEDSTATUSCODES")

        if c.server.enableCHUNKING </span><span class="cov3" title="9">{
                caps.WriteString("\nCHUNKING")
        }</span>

        <span class="cov6" title="57">isTLS := c.IsTLS()

        if !isTLS &amp;&amp; c.server.tlsConfig != nil </span><span class="cov2" title="3">{
                caps.WriteString("\nSTARTTLS")
        }</span>

        <span class="cov6" title="57">c.mechanisms = c.session.AuthMechanisms(c.ctx)
        if len(c.mechanisms) &gt; 0 </span><span class="cov6" title="49">{
                caps.WriteString("\nAUTH")
                for _, name := range c.mechanisms </span><span class="cov6" title="49">{
                        caps.WriteByte(' ')
                        caps.WriteString(name)
                }</span>
        } else<span class="cov3" title="8"> if c.server.enforceAuthentication </span><span class="cov0" title="0">{
                // without any auth mechanism, no authentication can happen =&gt; deadlock
                return c.newStatusError(451, smtp.EnhancedCode{4, 0, 0}, "No auth mechanism available but authentication enforced", err)
        }</span>

        <span class="cov6" title="57">if c.server.enableSMTPUTF8 </span><span class="cov1" title="2">{
                caps.WriteString("\nSMTPUTF8")
        }</span>
        <span class="cov6" title="57">if isTLS &amp;&amp; c.server.enableREQUIRETLS </span><span class="cov0" title="0">{
                caps.WriteString("\nREQUIRETLS")
        }</span>
        <span class="cov6" title="57">if c.server.enableBINARYMIME </span><span class="cov1" title="1">{
                caps.WriteString("\nBINARYMIME")
        }</span>
        <span class="cov6" title="57">if c.server.enableDSN </span><span class="cov1" title="2">{
                caps.WriteString("\nDSN")
        }</span>
        <span class="cov6" title="57">if c.server.enableXOORG </span><span class="cov1" title="1">{
                caps.WriteString("\nXOORG")
        }</span>
        <span class="cov6" title="57">if c.server.maxMessageBytes &gt; 0 </span><span class="cov4" title="10">{
                caps.WriteString(fmt.Sprintf("\nSIZE %v", c.server.maxMessageBytes))
        }</span> else<span class="cov6" title="47"> {
                caps.WriteString("\nSIZE")
        }</span>
        <span class="cov6" title="57">if c.server.maxRecipients &gt; 0 </span><span class="cov3" title="7">{
                caps.WriteString(fmt.Sprintf("\nLIMITS RCPTMAX=%v", c.server.maxRecipients))
        }</span>

        <span class="cov6" title="57">return smtp.NewStatus(250, smtp.NoEnhancedCode, caps.String())</span>
}

// handleError handles error and closes the connection afterwards.
func (c *Conn) handleError(err error) <span class="cov6" title="56">{
        if err == io.EOF || errors.Is(err, net.ErrClosed) </span><span class="cov6" title="50">{
                c.Close(fmt.Errorf("connection closed unexpectedly: %w", err))
                return
        }</span>

        <span class="cov3" title="6">if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() </span><span class="cov0" title="0">{
                c.writeResponse(421, smtp.EnhancedCode{4, 4, 2}, "Idle timeout, bye bye")
                c.Close(fmt.Errorf("idle timeout: %w", err))
                return
        }</span>

        <span class="cov3" title="6">if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov1" title="2">{
                c.writeResponse(smtpErr.Code, smtpErr.EnhancedCode, smtpErr.Message)

                if smtpErr.Code != 221 </span><span class="cov0" title="0">{
                        c.Close(fmt.Errorf("smtp error: %w", err))
                }</span> else<span class="cov1" title="2"> {
                        c.Close(nil)
                }</span>

                <span class="cov1" title="2">return</span>
        }

        <span class="cov2" title="4">if err == textsmtp.ErrTooLongLine </span><span class="cov1" title="2">{
                c.writeResponse(500, smtp.EnhancedCode{5, 4, 0}, "Too long line")
                c.Close(errors.New("line too long"))
                return
        }</span>

        <span class="cov1" title="2">c.writeStatus(smtp.ErrConnection)
        c.Close(fmt.Errorf("unknown error: %w", err))</span>
}

func (c *Conn) logger() *slog.Logger <span class="cov10" title="767">{
        // Fallback if the connection couldn't be created or is already closed.
        if c.session == nil </span><span class="cov0" title="0">{
                return slog.Default()
        }</span>
        <span class="cov10" title="767">logger := c.session.Logger(c.ctx)
        if logger == nil </span><span class="cov10" title="767">{
                return slog.Default()
        }</span>
        <span class="cov0" title="0">return logger</span>
}

// READY state -&gt; waiting for MAIL
// nolint: revive
func (c *Conn) handleMail(arg string) error <span class="cov6" title="42">{
        arg, ok := parse.CutPrefixFold(arg, "FROM:")
        if !ok </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Was expecting MAIL arg syntax of FROM:&lt;address&gt;")
        }</span>

        <span class="cov6" title="42">p := parse.Parser{S: strings.TrimSpace(arg)}
        from, err := p.ReversePath()
        if err != nil </span><span class="cov1" title="1">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Was expecting MAIL arg syntax of FROM:&lt;address&gt;")
        }</span>
        <span class="cov6" title="41">args, err := parse.Args(p.S)
        if err != nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unable to parse MAIL ESMTP parameters")
        }</span>

        <span class="cov6" title="41">opts := &amp;smtp.MailOptions{}

        c.binarymime = false
        // This is where the Conn may put BODY=8BITMIME, but we already
        // read the DATA as bytes, so it does not effect our processing.
        for key, value := range args </span><span class="cov5" title="21">{
                switch key </span>{
                case "SIZE":<span class="cov1" title="2">
                        size, err := strconv.ParseUint(value, 10, 32)
                        if err != nil </span><span class="cov1" title="1">{
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unable to parse SIZE as an integer")
                        }</span>

                        <span class="cov1" title="1">if c.server.maxMessageBytes &gt; 0 &amp;&amp; int64(size) &gt; c.server.maxMessageBytes </span><span class="cov1" title="1">{
                                return smtp.NewStatus(552, smtp.EnhancedCode{5, 3, 4}, "Max message size exceeded")
                        }</span>

                        <span class="cov0" title="0">opts.Size = int64(size)</span>
                case "XOORG":<span class="cov1" title="1">
                        value, err := decodeXtext(value)
                        if err != nil || value == "" </span><span class="cov0" title="0">{
                                return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 4}, "Malformed XOORG parameter value")
                        }</span>
                        <span class="cov1" title="1">if !c.server.enableXOORG </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "EnableXOORG is not implemented")
                        }</span>
                        <span class="cov1" title="1">opts.XOORG = &amp;value</span>
                case "SMTPUTF8":<span class="cov2" title="3">
                        if !c.server.enableSMTPUTF8 </span><span class="cov1" title="2">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "SMTPUTF8 is not implemented")
                        }</span>
                        <span class="cov1" title="1">opts.UTF8 = true</span>
                case "REQUIRETLS":<span class="cov0" title="0">
                        if !c.server.enableREQUIRETLS </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "REQUIRETLS is not implemented")
                        }</span>
                        <span class="cov0" title="0">opts.RequireTLS = true</span>
                case "BODY":<span class="cov3" title="7">
                        value = strings.ToUpper(value)
                        switch smtp.BodyType(value) </span>{
                        case smtp.BodyBinaryMIME:<span class="cov1" title="1">
                                if !c.server.enableBINARYMIME </span><span class="cov0" title="0">{
                                        return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "BINARYMIME is not implemented")
                                }</span>
                                <span class="cov1" title="1">c.binarymime = true</span>
                        case smtp.Body7Bit, smtp.Body8BitMIME:<span class="cov3" title="5"></span>
                                // This space is intentionally left blank
                        default:<span class="cov1" title="1">
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unknown BODY value")</span>
                        }
                        <span class="cov3" title="6">opts.Body = smtp.BodyType(value)</span>
                case "RET":<span class="cov1" title="2">
                        if !c.server.enableDSN </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "RET is not implemented")
                        }</span>
                        <span class="cov1" title="2">value = strings.ToUpper(value)
                        switch smtp.DSNReturn(value) </span>{
                        case smtp.DSNReturnFull, smtp.DSNReturnHeaders:<span class="cov1" title="2"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unknown RET value")</span>
                        }
                        <span class="cov1" title="2">opts.Return = smtp.DSNReturn(value)</span>
                case "ENVID":<span class="cov1" title="2">
                        if !c.server.enableDSN </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "ENVID is not implemented")
                        }</span>
                        <span class="cov1" title="2">value, err := decodeXtext(value)
                        if err != nil || value == "" || !textsmtp.IsPrintableASCII(value) </span><span class="cov0" title="0">{
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Malformed ENVID parameter value")
                        }</span>
                        <span class="cov1" title="2">opts.EnvelopeID = value</span>
                case "AUTH":<span class="cov2" title="3">
                        value, err := decodeXtext(value)
                        if err != nil || value == "" </span><span class="cov1" title="2">{
                                return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 4}, "Malformed AUTH parameter value")
                        }</span>
                        <span class="cov1" title="1">if value == "&lt;&gt;" </span><span class="cov0" title="0">{
                                value = ""
                        }</span> else<span class="cov1" title="1"> {
                                p := parse.Parser{S: value}
                                value, err = p.Mailbox()
                                if err != nil || p.S != "" </span><span class="cov0" title="0">{
                                        return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 4}, "Malformed AUTH parameter mailbox")
                                }</span>
                        }
                        <span class="cov1" title="1">opts.Auth = &amp;value</span>
                default:<span class="cov1" title="1">
                        return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 4}, "Unknown MAIL FROM argument")</span>
                }
        }

        <span class="cov5" title="33">if err := c.session.Mail(c.ctx, from, opts); err != nil </span><span class="cov1" title="1">{
                if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov1" title="1">{
                        // a positive response also counts as a success
                        if smtpErr.Positive() </span><span class="cov0" title="0">{
                                c.state = stateMail
                        }</span>
                        <span class="cov1" title="1">return smtpErr</span>
                }
                <span class="cov0" title="0">return c.newStatusError(451, smtp.EnhancedCode{4, 0, 0}, "Mail not accepted", err)</span>
        }

        <span class="cov5" title="31">c.state = stateMail
        return smtp.NewStatus(250, smtp.EnhancedCode{2, 0, 0}, fmt.Sprintf("Roger, accepting mail from &lt;%v&gt;", from))</span>
}

// MAIL state -&gt; waiting for RCPTs followed by DATA
func (c *Conn) handleRcpt(arg string) error <span class="cov5" title="31">{
        arg, ok := parse.CutPrefixFold(arg, "TO:")
        if !ok </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Was expecting RCPT arg syntax of TO:&lt;address&gt;")
        }</span>

        <span class="cov5" title="31">p := parse.Parser{S: strings.TrimSpace(arg)}
        recipient, err := p.Path()
        if err != nil </span><span class="cov1" title="1">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Was expecting RCPT arg syntax of TO:&lt;address&gt;")
        }</span>

        <span class="cov5" title="30">if c.server.maxRecipients &gt; 0 &amp;&amp; c.recipients &gt;= c.server.maxRecipients </span><span class="cov0" title="0">{
                return smtp.NewStatus(452, smtp.EnhancedCode{4, 5, 3}, fmt.Sprintf("Maximum limit of %v recipients reached", c.server.maxRecipients))
        }</span>

        <span class="cov5" title="30">args, err := parse.Args(p.S)
        if err != nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unable to parse RCPT ESMTP parameters")
        }</span>

        <span class="cov5" title="30">opts := &amp;smtp.RcptOptions{}

        for key, value := range args </span><span class="cov4" title="10">{
                switch key </span>{
                case "NOTIFY":<span class="cov3" title="5">
                        if !c.server.enableDSN </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "NOTIFY is not implemented")
                        }</span>
                        <span class="cov3" title="5">notify := []smtp.DSNNotify{}
                        for _, val := range strings.Split(value, ",") </span><span class="cov3" title="7">{
                                notify = append(notify, smtp.DSNNotify(strings.ToUpper(val)))
                        }</span>
                        <span class="cov3" title="5">if err := textsmtp.CheckNotifySet(notify); err != nil </span><span class="cov0" title="0">{
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Malformed NOTIFY parameter value")
                        }</span>
                        <span class="cov3" title="5">opts.Notify = notify</span>
                case "ORCPT":<span class="cov3" title="5">
                        if !c.server.enableDSN </span><span class="cov0" title="0">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "ORCPT is not implemented")
                        }</span>
                        <span class="cov3" title="5">aType, aAddr, err := decodeTypedAddress(value)
                        if err != nil || aAddr == "" </span><span class="cov0" title="0">{
                                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Malformed ORCPT parameter value")
                        }</span>
                        <span class="cov3" title="5">opts.OriginalRecipientType = aType
                        opts.OriginalRecipient = aAddr</span>
                default:<span class="cov0" title="0">
                        return smtp.NewStatus(500, smtp.EnhancedCode{5, 5, 4}, "Unknown RCPT TO argument")</span>
                }
        }

        <span class="cov5" title="30">if err := c.session.Rcpt(c.ctx, recipient, opts); err != nil </span><span class="cov0" title="0">{
                if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov0" title="0">{
                        // a positive response also counts as a success
                        if smtpErr.Positive() </span><span class="cov0" title="0">{
                                c.recipients++
                        }</span>
                        <span class="cov0" title="0">return smtpErr</span>
                }
                <span class="cov0" title="0">return c.newStatusError(451, smtp.EnhancedCode{4, 0, 0}, "Recipient not accepted", err)</span>
        }

        <span class="cov5" title="30">c.recipients++
        return smtp.NewStatus(250, smtp.EnhancedCode{2, 0, 0}, fmt.Sprintf("I'll make sure &lt;%v&gt; gets this", recipient))</span>
}

func (c *Conn) handleVrfy(arg string) error <span class="cov2" title="3">{
        p := parse.Parser{S: strings.TrimSpace(arg)}
        vrfy, err := p.Path()
        if err != nil </span><span class="cov1" title="1">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 2}, "Was expecting &lt;address&gt;")
        }</span>
        <span class="cov1" title="2">args, err := parse.Args(p.S)
        if err != nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "Unable to parse VRFY ESMTP parameters")
        }</span>

        <span class="cov1" title="2">opts := &amp;smtp.VrfyOptions{}

        for key := range args </span><span class="cov1" title="1">{
                if key == "SMTPUTF8" </span><span class="cov1" title="1">{
                        if !c.server.enableSMTPUTF8 </span><span class="cov1" title="1">{
                                return smtp.NewStatus(504, smtp.EnhancedCode{5, 5, 4}, "SMTPUTF8 is not implemented")
                        }</span>
                        <span class="cov0" title="0">opts.UTF8 = true</span>
                }
        }

        <span class="cov1" title="1">res := c.session.Verify(c.ctx, vrfy, opts)

        if res == nil </span><span class="cov1" title="1">{
                return smtp.VRFY
        }</span>

        <span class="cov0" title="0">return res</span>
}

func (c *Conn) handleAuth(arg string) error <span class="cov6" title="41">{
        if c.didAuth </span><span class="cov1" title="2">{
                return smtp.NewStatus(503, smtp.EnhancedCode{5, 5, 1}, "Already authenticated")
        }</span>
        <span class="cov5" title="39">parts := strings.Fields(arg)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 4}, "Missing parameter")
        }</span>

        <span class="cov5" title="39">mechanism := strings.ToUpper(parts[0])

        // Is mechanism allowed?
        if !slices.Contains(c.mechanisms, mechanism) </span><span class="cov1" title="1">{
                return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 4}, "Invalid mechanism")
        }</span>

        // Parse client initial response if there is one
        <span class="cov5" title="38">var ir []byte
        if len(parts) &gt; 1 </span><span class="cov3" title="7">{
                var err error
                ir, err = decodeSASLResponse(parts[1])
                if err != nil </span><span class="cov1" title="2">{
                        return smtp.NewStatus(454, smtp.EnhancedCode{4, 7, 0}, "Invalid base64 data")
                }</span>
        }

        <span class="cov5" title="36">sasl, err := c.session.Auth(c.ctx, mechanism)
        if err != nil </span><span class="cov0" title="0">{
                return c.newStatusError(454, smtp.EnhancedCode{4, 7, 0}, "Authentication failed", err)
        }</span>

        <span class="cov5" title="36">if sasl == nil </span><span class="cov0" title="0">{
                return c.newStatusError(451, smtp.EnhancedCode{4, 0, 0}, "No auth handler received, but mechanism seems valid.", err)
        }</span>

        <span class="cov5" title="36">response := ir
        for </span><span class="cov6" title="66">{
                challenge, done, err := sasl.Next(response)
                if err != nil </span><span class="cov0" title="0">{
                        return c.newStatusError(454, smtp.EnhancedCode{4, 7, 0}, "Authentication failed", err)
                }</span>

                <span class="cov6" title="66">if done </span><span class="cov5" title="35">{
                        break</span>
                }

                <span class="cov5" title="31">encoded := ""
                if len(challenge) &gt; 0 </span><span class="cov0" title="0">{
                        encoded = base64.StdEncoding.EncodeToString(challenge)
                }</span>
                <span class="cov5" title="31">c.writeResponse(334, smtp.NoEnhancedCode, encoded)

                encoded, err = c.readLine()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="31">if encoded == "*" </span><span class="cov1" title="1">{
                        // https://tools.ietf.org/html/rfc4954#page-4
                        return smtp.NewStatus(501, smtp.EnhancedCode{5, 0, 0}, "Negotiation cancelled")
                }</span>

                <span class="cov5" title="30">response, err = decodeSASLResponse(encoded)
                if err != nil </span><span class="cov0" title="0">{
                        return smtp.NewStatus(454, smtp.EnhancedCode{4, 7, 0}, "Invalid base64 data")
                }</span>
        }

        <span class="cov5" title="35">c.didAuth = true
        if c.state == stateEnforceAuthentication </span><span class="cov1" title="2">{
                c.state = stateGreeted
        }</span>

        <span class="cov5" title="35">return smtp.NewStatus(235, smtp.EnhancedCode{2, 0, 0}, "Authentication succeeded")</span>
}

func (c *Conn) handleStartTLS() error <span class="cov1" title="2">{
        if _, isTLS := c.TLSConnectionState(); isTLS </span><span class="cov0" title="0">{
                return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 1}, "Already running in TLS")
        }</span>

        <span class="cov1" title="2">if c.server.tlsConfig == nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 1}, "TLS not supported")
        }</span>

        // allow the session to change tlsConfig
        <span class="cov1" title="2">tlsConfig, err := c.session.STARTTLS(c.ctx, c.server.tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return c.newStatusError(451, smtp.EnhancedCode{4, 0, 0}, "TLS config retrieval failed", err)
        }</span>
        <span class="cov1" title="2">if tlsConfig == nil </span><span class="cov0" title="0">{
                return smtp.NewStatus(451, smtp.EnhancedCode{4, 0, 0}, "TLS config retrieval nil returned")
        }</span>

        <span class="cov1" title="2">c.writeResponse(220, smtp.EnhancedCode{2, 0, 0}, "Ready to start TLS")

        // Upgrade to TLS
        tlsConn := tls.Server(c.conn, tlsConfig)

        if err := tlsConn.HandshakeContext(c.ctx); err != nil </span><span class="cov0" title="0">{
                c.logger().ErrorContext(c.ctx, "handleStartTLS", slog.Any("err", err))
                return smtp.NewStatus(550, smtp.EnhancedCode{5, 0, 0}, "Handshake error")
        }</span>

        <span class="cov1" title="2">c.conn = tlsConn
        c.text.Replace(tlsConn)
        c.state = stateUpgrade // same as StateInit but calls logout/reset on ehlo/helo

        return nil</span>
}

// DATA
func (c *Conn) handleData(arg string) error <span class="cov4" title="17">{
        // at least a single recipient needs to be set
        if c.recipients == 0 </span><span class="cov1" title="1">{
                return smtp.ErrNoRecipients
        }</span>

        <span class="cov4" title="16">if arg != "" </span><span class="cov0" title="0">{
                return smtp.NewStatus(501, smtp.EnhancedCode{5, 5, 4}, "DATA command should not have any arguments")
        }</span>
        <span class="cov4" title="16">if c.binarymime </span><span class="cov0" title="0">{
                return smtp.NewStatus(502, smtp.EnhancedCode{5, 5, 1}, "DATA not allowed for BINARYMIME messages")
        }</span>

        <span class="cov4" title="16">var r io.Reader

        rstart := func() io.Reader </span><span class="cov4" title="16">{
                if r != nil </span><span class="cov0" title="0">{
                        return r
                }</span>
                // We have recipients, go to accept data
                <span class="cov4" title="16">c.writeResponse(354, smtp.NoEnhancedCode, "Go ahead. End your data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;")

                r := textsmtp.NewDotReader(c.text.R, c.server.maxMessageBytes)
                return r</span>
        }

        <span class="cov4" title="16">uuid, err := c.session.Data(c.ctx, rstart)
        if err != nil </span><span class="cov1" title="1">{
                // an error which isn't a SMTPStatus error will always terminate the connection
                // if it is an SMTPStatus then wi need to make sure the stream ist read to the end
                if _, ok := err.(*smtp.Status); ok &amp;&amp; r != nil </span><span class="cov0" title="0">{
                        _, _ = io.Copy(io.Discard, r)
                }</span>
                <span class="cov1" title="1">return err</span>
        }

        // Make sure all the data has been consumed
        <span class="cov4" title="15">if r != nil </span><span class="cov0" title="0">{
                _, _ = io.Copy(io.Discard, r)
        }</span>

        <span class="cov4" title="15">if err = c.reset(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="15">return c.accepted(uuid)</span>
}

func (c *Conn) handleBdat(arg string) error <span class="cov3" title="9">{
        // at least a single recipient needs to be set
        if c.recipients == 0 </span><span class="cov0" title="0">{
                return smtp.ErrNoRecipients
        }</span>

        <span class="cov3" title="9">closed := false

        size, last, err := bdatArg(arg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="9">data := &amp;bdat{
                maxMessageBytes: c.server.maxMessageBytes,
                size:            size,
                last:            last,
                bytesReceived:   0,
                input:           c.text.R,
                nextCommand: func() (string, string, error) </span><span class="cov4" title="10">{
                        // if bdat is closed (error occurred)
                        if closed </span><span class="cov2" title="4">{
                                return "", "", io.EOF
                        }</span>
                        <span class="cov3" title="6">c.writeResponse(250, smtp.EnhancedCode{2, 0, 0}, "Continue")
                        return c.nextCommand()</span>
                },
        }

        <span class="cov3" title="9">queueid, err := c.session.Data(c.ctx, func() io.Reader </span><span class="cov3" title="7">{
                return data
        }</span>)
        <span class="cov3" title="9">if err != nil </span><span class="cov3" title="6">{
                if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov3" title="6">{
                        // write down error
                        c.writeStatus(smtpErr)
                        // read anything left to continue after this failure, ignore any read error
                        // https://www.rfc-editor.org/rfc/rfc3030.html
                        // If a 5XX or 4XX code is received by the sender-SMTP in response to a BDAT
                        // chunk, the transaction should be considered failed and the sender-
                        // SMTP MUST NOT send any additional BDAT segments.  If the receiver-
                        // SMTP has declared support for command pipelining [PIPE], the receiver
                        // SMTP MUST be prepared to accept and discard additional BDAT chunks
                        // already in the pipeline after the failed BDAT.
                        closed = true
                        _, _ = io.Copy(io.Discard, data)
                        return c.reset()
                }</span>
                // an error which isn't a SMTPStatus error will always terminate the connection
                <span class="cov0" title="0">return err</span>
        }

        // Make sure all the data has been consumed
        <span class="cov2" title="3">_, _ = io.Copy(io.Discard, data)

        if err = c.reset(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="3">return c.accepted(queueid)</span>
}

func (*Conn) accepted(queueid string) *smtp.Status <span class="cov4" title="18">{
        if queueid != "" </span><span class="cov0" title="0">{
                // limit length if queueid is too long (&lt; 1000)
                if len(queueid) &gt; 977 </span><span class="cov0" title="0">{
                        queueid = queueid[:974] + "..."
                }</span>
                <span class="cov0" title="0">return smtp.NewStatus(250, smtp.EnhancedCode{2, 0, 0}, "OK: queued as "+queueid)</span>
        }
        <span class="cov4" title="18">return smtp.NewStatus(250, smtp.EnhancedCode{2, 0, 0}, "OK: queued")</span>
}

func (c *Conn) greet() <span class="cov6" title="59">{
        protocol := "ESMTP"
        c.writeResponse(220, smtp.NoEnhancedCode, fmt.Sprintf("%v %s Service Ready", c.server.hostname, protocol))
}</span>

func (c *Conn) writeStatus(status *smtp.Status) <span class="cov8" title="217">{
        c.writeResponse(status.Code, status.EnhancedCode, status.Message)
}</span>

func (c *Conn) writeResponse(code int, enhCode smtp.EnhancedCode, text string) <span class="cov8" title="336">{
        c.logger().DebugContext(c.ctx, "write", slog.Int("code", code), slog.Any("enhCode", enhCode), slog.Any("text", text))

        // TODO: error handling
        if c.server.writeTimeout != 0 </span><span class="cov5" title="31">{
                _ = c.conn.SetWriteDeadline(time.Now().Add(c.server.writeTimeout))
        }</span>

        // All responses must include an enhanced code, if it is missing - use
        // a generic code X.0.0.
        <span class="cov8" title="336">if enhCode == smtp.EnhancedCodeNotSet </span><span class="cov0" title="0">{
                cat := code / 100
                switch cat </span>{
                case 2, 4, 5:<span class="cov0" title="0">
                        enhCode = smtp.EnhancedCode{cat, 0, 0}</span>
                default:<span class="cov0" title="0">
                        enhCode = smtp.NoEnhancedCode</span>
                }
        }

        <span class="cov8" title="336">p := 0
        for </span><span class="cov9" title="638">{
                i := strings.IndexByte(text[p:], '\n')
                if i &lt; 0 </span><span class="cov8" title="336">{
                        break</span>
                }

                <span class="cov8" title="302">_ = c.text.PrintfLine("%d-%v", code, text[p:p+i])
                p += i + 1</span>
        }

        <span class="cov8" title="336">if enhCode == smtp.NoEnhancedCode </span><span class="cov7" title="163">{
                _ = c.text.PrintfLineAndFlush("%d %v", code, text[p:])
        }</span> else<span class="cov7" title="173"> {
                _ = c.text.PrintfLineAndFlush("%d %v.%v.%v %v", code, enhCode[0], enhCode[1], enhCode[2], text[p:])
        }</span>
}

func (c *Conn) newStatusError(code int, enhCode smtp.EnhancedCode, msg string, err error) *smtp.Status <span class="cov0" title="0">{
        if smtpErr, ok := err.(*smtp.Status); ok </span><span class="cov0" title="0">{
                return smtpErr
        }</span>
        <span class="cov0" title="0">c.logger().ErrorContext(c.ctx, msg, slog.Any("err", err))
        return smtp.NewStatus(code, enhCode, msg)</span>
}

// Reads a line of input
func (c *Conn) readLine() (string, error) <span class="cov8" title="313">{
        if c.server.readTimeout != 0 </span><span class="cov5" title="27">{
                _ = c.conn.SetReadDeadline(time.Now().Add(c.server.readTimeout))
        }</span>
        <span class="cov8" title="313">line, err := c.text.ReadLine()
        if err == nil </span><span class="cov8" title="259">{
                c.logger().DebugContext(c.ctx, "read", slog.String("line", line))
        }</span>
        <span class="cov8" title="311">return line, err</span>
}

func (c *Conn) reset() error <span class="cov5" title="27">{
        // Reset state to Greeted
        if c.state == stateMail </span><span class="cov5" title="24">{
                c.state = stateGreeted
        }</span>

        <span class="cov5" title="27">c.recipients = 0

        upgrade := c.state == stateUpgrade

        // Authentication is only revoked if starttls is used.
        if upgrade </span><span class="cov1" title="2">{
                c.didAuth = false
        }</span>
        <span class="cov5" title="27">ctx, err := c.session.Reset(c.ctx, upgrade)
        c.ctx = ctx
        return err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package server

import (
        "encoding/base64"
        "errors"
        "regexp"
        "strconv"
        "strings"

        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/internal/textsmtp"
)

func decodeSASLResponse(s string) ([]byte, error) <span class="cov10" title="37">{
        if s == "=" </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>
        <span class="cov10" title="37">return base64.StdEncoding.DecodeString(s)</span>
}

// This regexp matches 'hexchar' token defined in
// https://tools.ietf.org/html/rfc4954#section-8 however it is intentionally
// relaxed by requiring only '+' to be present.  It allows us to detect
// malformed values such as +A or +HH and report them appropriately.
var hexcharRe = regexp.MustCompile(`\+[0-9A-F]?[0-9A-F]?`)

func decodeXtext(val string) (string, error) <span class="cov6" title="8">{
        if !strings.Contains(val, "+") </span><span class="cov1" title="1">{
                return val, nil
        }</span>

        <span class="cov5" title="7">var replaceErr error
        decoded := hexcharRe.ReplaceAllStringFunc(val, func(match string) string </span><span class="cov5" title="7">{
                if len(match) != 3 </span><span class="cov2" title="2">{
                        replaceErr = errors.New("incomplete hexchar")
                        return ""
                }</span>
                <span class="cov5" title="5">char, err := strconv.ParseInt(match, 16, 8)
                if err != nil </span><span class="cov0" title="0">{
                        replaceErr = err
                        return ""
                }</span>

                <span class="cov5" title="5">return string(rune(char))</span>
        })
        <span class="cov5" title="7">if replaceErr != nil </span><span class="cov2" title="2">{
                return "", replaceErr
        }</span>

        <span class="cov5" title="5">return decoded, nil</span>
}

// This regexp matches 'EmbeddedUnicodeChar' token defined in
// https://datatracker.ietf.org/doc/html/rfc6533.html#section-3
// however it is intentionally relaxed by requiring only '\x{HEX}' to be
// present.  It also matches disallowed characters in QCHAR and QUCHAR defined
// in above.
// So it allows us to detect malformed values and report them appropriately.
var eUOrDCharRe = regexp.MustCompile(`\\x[{][0-9A-F]+[}]|[[:cntrl:] \\+=]`)

// Decodes the utf-8-addr-xtext or the utf-8-addr-unitext form.
func decodeUTF8AddrXtext(val string) (string, error) <span class="cov3" title="3">{
        var replaceErr error
        decoded := eUOrDCharRe.ReplaceAllStringFunc(val, func(match string) string </span><span class="cov7" title="15">{
                if len(match) == 1 </span><span class="cov0" title="0">{
                        replaceErr = errors.New("disallowed character:" + match)
                        return ""
                }</span>

                <span class="cov7" title="15">hexpoint := match[3 : len(match)-1]
                char, err := strconv.ParseUint(hexpoint, 16, 21)
                if err != nil </span><span class="cov0" title="0">{
                        replaceErr = err
                        return ""
                }</span>
                <span class="cov7" title="15">switch len(hexpoint) </span>{
                case 2:<span class="cov3" title="3">
                        switch </span>{
                        // all xtext-specials
                        case 0x01 &lt;= char &amp;&amp; char &lt;= 0x09 ||
                                0x11 &lt;= char &amp;&amp; char &lt;= 0x19 ||
                                char == 0x10 || char == 0x20 ||
                                char == 0x2B || char == 0x3D || char == 0x7F:<span class="cov3" title="3"></span>
                        // 2-digit forms
                        case char == 0x5C || 0x80 &lt;= char &amp;&amp; char &lt;= 0xFF:<span class="cov0" title="0"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                                return ""</span>
                        }
                // 3-digit forms
                case 3:<span class="cov0" title="0">
                        switch </span>{
                        case 0x100 &lt;= char &amp;&amp; char &lt;= 0xFFF:<span class="cov0" title="0"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                                return ""</span>
                        }
                // 4-digit forms excluding surrogate
                case 4:<span class="cov7" title="12">
                        switch </span>{
                        case 0x1000 &lt;= char &amp;&amp; char &lt;= 0xD7FF:<span class="cov7" title="12"></span>
                        case 0xE000 &lt;= char &amp;&amp; char &lt;= 0xFFFF:<span class="cov0" title="0"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                                return ""</span>
                        }
                // 5-digit forms
                case 5:<span class="cov0" title="0">
                        switch </span>{
                        case 0x1_0000 &lt;= char &amp;&amp; char &lt;= 0xF_FFFF:<span class="cov0" title="0"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                                return ""</span>
                        }
                // 6-digit forms
                case 6:<span class="cov0" title="0">
                        switch </span>{
                        case 0x10_0000 &lt;= char &amp;&amp; char &lt;= 0x10_FFFF:<span class="cov0" title="0"></span>
                                // This space is intentionally left blank
                        default:<span class="cov0" title="0">
                                replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                                return ""</span>
                        }
                // the other invalid forms
                default:<span class="cov0" title="0">
                        replaceErr = errors.New("illegal hexpoint:" + hexpoint)
                        return ""</span>
                }

                <span class="cov7" title="15">return string(rune(char))</span>
        })
        <span class="cov3" title="3">if replaceErr != nil </span><span class="cov0" title="0">{
                return "", replaceErr
        }</span>

        <span class="cov3" title="3">return decoded, nil</span>
}

func decodeTypedAddress(val string) (smtp.DSNAddressType, string, error) <span class="cov5" title="5">{
        tv := strings.SplitN(val, ";", 2)
        if len(tv) != 2 || tv[0] == "" || tv[1] == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("bad address")
        }</span>
        <span class="cov5" title="5">aType, aAddr := strings.ToUpper(tv[0]), tv[1]

        var err error
        switch smtp.DSNAddressType(aType) </span>{
        case smtp.DSNAddressTypeRFC822:<span class="cov2" title="2">
                aAddr, err = decodeXtext(aAddr)
                if err == nil &amp;&amp; !textsmtp.IsPrintableASCII(aAddr) </span><span class="cov0" title="0">{
                        err = errors.New("illegal address:" + aAddr)
                }</span>
        case smtp.DSNAddressTypeUTF8:<span class="cov3" title="3">
                aAddr, err = decodeUTF8AddrXtext(aAddr)</span>
        default:<span class="cov0" title="0">
                err = errors.New("unknown address type:" + aType)</span>
        }
        <span class="cov5" title="5">if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov5" title="5">return smtp.DSNAddressType(aType), aAddr, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "runtime/debug"
        "time"

        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/internal/textsmtp"
)

// Serve accepts incoming connections on the Listener l.
func (s *Server) Serve(ctx context.Context, l net.Listener) error <span class="cov8" title="55">{
        s.locker.Lock()
        s.listeners = append(s.listeners, l)
        s.locker.Unlock()

        var tempDelay time.Duration // how long to sleep on accept failure

        for </span><span class="cov10" title="115">{
                c, err := l.Accept()
                if err != nil </span><span class="cov8" title="44">{
                        select </span>{
                        case &lt;-s.done:<span class="cov8" title="42">
                                // we called Close()
                                return nil</span>
                        default:<span class="cov2" title="2"></span>
                        }
                        <span class="cov2" title="2">if ne, ok := err.(net.Error); ok &amp;&amp; ne.Timeout() </span><span class="cov1" title="1">{
                                if tempDelay == 0 </span><span class="cov1" title="1">{
                                        tempDelay = 5 * time.Millisecond
                                }</span> else<span class="cov0" title="0"> {
                                        tempDelay *= 2
                                }</span>
                                <span class="cov1" title="1">if maxDelay := 1 * time.Second; tempDelay &gt; maxDelay </span><span class="cov0" title="0">{
                                        tempDelay = maxDelay
                                }</span>
                                <span class="cov1" title="1">s.logger.ErrorContext(
                                        ctx,
                                        "accept error, retrying",
                                        slog.Any("err", err),
                                        slog.Any("temp_delay", tempDelay),
                                )
                                time.Sleep(tempDelay)
                                continue</span>
                        }
                        <span class="cov1" title="1">return err</span>
                }

                <span class="cov8" title="59">s.wg.Add(1)
                go s.handleConn(ctx, c)</span>
        }
}

func (s *Server) handleConn(ctx context.Context, conn net.Conn) <span class="cov8" title="59">{
        ctx, cancel := context.WithCancel(ctx)

        c := &amp;Conn{
                ctx:    ctx,
                server: s,
                conn:   conn,
                text:   textsmtp.NewTextproto(conn, s.readerSize, s.writerSize, s.maxLineLength),
        }

        s.locker.Lock()
        s.conns[c] = struct{}{}
        s.locker.Unlock()

        var err error

        defer func() </span><span class="cov8" title="57">{
                if err := recover(); err != nil </span><span class="cov1" title="1">{
                        c.writeResponse(421, smtp.EnhancedCode{4, 0, 0}, "Internal server error")
                        stack := debug.Stack()
                        c.logger().ErrorContext(
                                c.ctx,
                                "panic serving",
                                slog.Any("err", err),
                                slog.Any("stack", string(stack)),
                        )
                        c.Close(errors.New("recovered from panic inside handleConn"))
                }</span>

                <span class="cov8" title="57">s.locker.Lock()
                delete(s.conns, c)
                s.locker.Unlock()

                s.wg.Done()

                cancel()</span>
        }()

        <span class="cov8" title="59">sctx, session, err := s.backend.NewSession(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                c.Close(fmt.Errorf("couldn't create connection wrapper: %w", err))
                return
        }</span>

        // update ctx and set session
        <span class="cov8" title="59">c.ctx = sctx
        c.session = session

        c.logger().DebugContext(c.ctx, "connection is opened")

        // explicit tls handshake call
        if tlsConn, ok := c.conn.(*tls.Conn); ok </span><span class="cov1" title="1">{
                if d := s.readTimeout; d != 0 </span><span class="cov0" title="0">{
                        _ = c.conn.SetReadDeadline(time.Now().Add(d))
                }</span>
                <span class="cov1" title="1">if d := s.writeTimeout; d != 0 </span><span class="cov0" title="0">{
                        _ = c.conn.SetWriteDeadline(time.Now().Add(d))
                }</span>
                <span class="cov1" title="1">if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        c.handleError(err)
                        return
                }</span>
        }

        // run always returns an error when finished
        <span class="cov8" title="59">c.handleError(c.run())</span>
}

// Listen listens on the network address s.Addr
// to handle requests on incoming connections.
//
// If s.Addr is blank and LMTP is disabled, ":smtp" is used.
func (s *Server) Listen() (net.Listener, error) <span class="cov8" title="54">{
        network := s.network
        if network == "" </span><span class="cov8" title="54">{
                network = "tcp"
        }</span>

        <span class="cov8" title="54">addr := s.addr
        if addr == "" </span><span class="cov0" title="0">{
                addr = ":smtp"
        }</span>

        <span class="cov8" title="54">var l net.Listener
        var err error

        if s.implicitTLS </span><span class="cov1" title="1">{
                l, err = tls.Listen(network, addr, s.tlsConfig)
        }</span> else<span class="cov8" title="53"> {
                l, err = net.Listen(network, addr)
        }</span>

        <span class="cov8" title="54">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="54">return l, nil</span>
}

// ListenAndServe listens on the network address s.Addr and then calls Serve
// to handle requests on incoming connections.
//
// If s.Addr is blank and LMTP is disabled, ":smtp" is used.
func (s *Server) ListenAndServe(ctx context.Context) error <span class="cov0" title="0">{
        network := s.network
        if network == "" </span><span class="cov0" title="0">{
                network = "tcp"
        }</span>

        <span class="cov0" title="0">addr := s.addr
        if addr == "" </span><span class="cov0" title="0">{
                addr = ":smtp"
        }</span>

        <span class="cov0" title="0">var l net.Listener
        var err error

        if s.implicitTLS </span><span class="cov0" title="0">{
                l, err = tls.Listen(network, addr, s.tlsConfig)
        }</span> else<span class="cov0" title="0"> {
                l, err = net.Listen(network, addr)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.Serve(ctx, l)</span>
}

// Close immediately closes all active listeners and connections.
//
// Close returns any error returned from closing the server's underlying
// listener(s).
func (s *Server) Close() error <span class="cov8" title="42">{
        select </span>{
        case &lt;-s.done:<span class="cov0" title="0">
                return ErrServerClosed</span>
        default:<span class="cov8" title="42">
                close(s.done)</span>
        }

        <span class="cov8" title="42">var err error
        s.locker.Lock()
        for _, l := range s.listeners </span><span class="cov8" title="42">{
                if lerr := l.Close(); lerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = lerr
                }</span>
        }

        <span class="cov8" title="42">for conn := range s.conns </span><span class="cov7" title="31">{
                // directly close underlying connection
                _ = conn.conn.Close()
        }</span>
        <span class="cov8" title="42">s.locker.Unlock()

        return err</span>
}

// Shutdown gracefully shuts down the server without interrupting any
// active connections. Shutdown works by first closing all open
// listeners and then waiting indefinitely for connections to return to
// idle and then shut down.
// If the provided context expires before the shutdown is complete,
// Shutdown returns the context's error, otherwise it returns any
// error returned from closing the Server's underlying Listener(s).
func (s *Server) Shutdown(ctx context.Context) error <span class="cov2" title="2">{
        select </span>{
        case &lt;-s.done:<span class="cov1" title="1">
                return ErrServerClosed</span>
        default:<span class="cov1" title="1">
                close(s.done)</span>
        }

        <span class="cov1" title="1">var err error
        s.locker.Lock()
        for _, l := range s.listeners </span><span class="cov1" title="1">{
                if lerr := l.Close(); lerr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = lerr
                }</span>
        }
        <span class="cov1" title="1">s.locker.Unlock()

        connDone := make(chan struct{})
        go func() </span><span class="cov1" title="1">{
                defer close(connDone)
                s.wg.Wait()
        }</span>()

        <span class="cov1" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-connDone:<span class="cov1" title="1">
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "crypto/tls"
        "errors"
        "log/slog"
        "net"
        "sync"
        "time"
)

// ErrServerClosed occurs if a server is already closed.
var ErrServerClosed = errors.New("smtp: server already closed")

// Server implements a SMTP server.
type Server struct {
        // The type of network, "tcp" or "unix".
        network string
        // TCP or Unix address to listen on.
        addr string
        // The server TLS configuration.
        tlsConfig *tls.Config

        hostname string

        maxRecipients int
        // Max line length for every command except data and bdat.
        maxLineLength int
        // Maximum size when receiving data and bdat.
        maxMessageBytes int64
        // Reader buffer size.
        readerSize int
        // Writer buffer size.
        writerSize int

        readTimeout  time.Duration
        writeTimeout time.Duration

        implicitTLS bool

        // Enforces usage of implicit tls or starttls before accepting commands except NOOP, EHLO, STARTTLS, or QUIT.
        enforceSecureConnection bool

        // Enforces usage of authentication.
        enforceAuthentication bool

        // Advertise SMTPUTF8 (RFC 6531) capability.
        // Should be used only if backend supports it.
        enableSMTPUTF8 bool

        // Advertise REQUIRETLS (RFC 8689) capability.
        // Should be used only if backend supports it.
        enableREQUIRETLS bool

        // Advertise CHUNKING (RFC 1830) capability.
        enableCHUNKING bool

        // Advertise BINARYMIME (RFC 3030) capability.
        // Should be used only if backend supports it.
        enableBINARYMIME bool

        // Advertise DSN (RFC 3461) capability.
        // Should be used only if backend supports it.
        enableDSN bool

        // Advertise XOORG capability.
        // Should be used only if backend supports it.
        enableXOORG bool

        // The server backend.
        backend Backend

        logger *slog.Logger

        wg   sync.WaitGroup
        done chan struct{}

        locker    sync.Mutex
        listeners []net.Listener
        conns     map[*Conn]struct{}
}

// Backend returns the servers Backend.
func (s *Server) Backend() Backend <span class="cov3" title="6">{
        return s.backend
}</span>

// Option is an option for the server.
type Option func(*Server)

// New creates a new SMTP server.
func New(opts ...Option) *Server <span class="cov7" title="55">{
        s := &amp;Server{
                done:     make(chan struct{}, 1),
                conns:    make(map[*Conn]struct{}),
                hostname: "localhost",
        }

        for _, o := range opts </span><span class="cov10" title="256">{
                o(s)
        }</span>

        <span class="cov7" title="55">if s.logger == nil </span><span class="cov7" title="53">{
                s.logger = slog.Default()
        }</span>

        <span class="cov7" title="55">return s</span>
}

// WithLogger sets the backend.
func WithLogger(logger *slog.Logger) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.logger = logger
        }</span>
}

// WithBackend sets the backend.
func WithBackend(backend Backend) Option <span class="cov7" title="55">{
        return func(s *Server) </span><span class="cov7" title="55">{
                s.backend = backend
        }</span>
}

// WithNetwork sets the network.
func WithNetwork(network string) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.network = network
        }</span>
}

// WithReadTimeout sets the read timeout.
func WithReadTimeout(readTimeout time.Duration) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.readTimeout = readTimeout
        }</span>
}

// WithWriteTimeout sets the write timeout.
func WithWriteTimeout(writeTimeout time.Duration) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.writeTimeout = writeTimeout
        }</span>
}

// WithMaxMessageBytes sets the max message size.
func WithMaxMessageBytes(maxMessageBytes int64) Option <span class="cov3" title="5">{
        return func(s *Server) </span><span class="cov3" title="5">{
                s.maxMessageBytes = maxMessageBytes
        }</span>
}

// WithMaxLineLength sets the max length per line.
func WithMaxLineLength(maxLineLength int) Option <span class="cov7" title="54">{
        return func(s *Server) </span><span class="cov7" title="54">{
                s.maxLineLength = maxLineLength
        }</span>
}

// WithMaxRecipients sets the max recipients per mail.
func WithMaxRecipients(maxRecipients int) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.maxRecipients = maxRecipients
        }</span>
}

// WithAddr sets addr.
func WithAddr(addr string) Option <span class="cov7" title="54">{
        return func(s *Server) </span><span class="cov7" title="54">{
                s.addr = addr
        }</span>
}

// WithEnableXOORG enables xoorg.
func WithEnableXOORG(enableXOORG bool) Option <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.enableXOORG = enableXOORG
        }</span>
}

// WithEnableBINARYMIME sets EnableBINARYMIME.
func WithEnableBINARYMIME(enableBINARYMIME bool) Option <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.enableBINARYMIME = enableBINARYMIME
        }</span>
}

// WithEnableREQUIRETLS sets EnableREQUIRETLS.
func WithEnableREQUIRETLS(enableREQUIRETLS bool) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.enableREQUIRETLS = enableREQUIRETLS
        }</span>
}

// WithEnableCHUNKING sets EnableCHUNKING.
func WithEnableCHUNKING(enableCHUNKING bool) Option <span class="cov4" title="9">{
        return func(s *Server) </span><span class="cov4" title="9">{
                s.enableCHUNKING = enableCHUNKING
        }</span>
}

// WithEnableSMTPUTF8 sets EnableSMTPUTF8.
func WithEnableSMTPUTF8(enableSMTPUTF8 bool) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.enableSMTPUTF8 = enableSMTPUTF8
        }</span>
}

// WithEnableDSN sets EnableDSN.
func WithEnableDSN(enableDSN bool) Option <span class="cov2" title="2">{
        return func(s *Server) </span><span class="cov2" title="2">{
                s.enableDSN = enableDSN
        }</span>
}

// WithImplicitTLS sets implicitTLS.
func WithImplicitTLS(implicitTLS bool) Option <span class="cov1" title="1">{
        return func(s *Server) </span><span class="cov1" title="1">{
                s.implicitTLS = implicitTLS
        }</span>
}

// WithHostname sets the domain.
func WithHostname(hostname string) Option <span class="cov7" title="52">{
        return func(s *Server) </span><span class="cov7" title="52">{
                s.hostname = hostname
        }</span>
}

// WithTLSConfig sets certificate.
func WithTLSConfig(tlsConfig *tls.Config) Option <span class="cov3" title="4">{
        return func(s *Server) </span><span class="cov3" title="4">{
                s.tlsConfig = tlsConfig
        }</span>
}

// WithEnforceSecureConnection enforces implicit TLS or STARTTLS.
func WithEnforceSecureConnection(enforceSecureConnection bool) Option <span class="cov3" title="5">{
        return func(s *Server) </span><span class="cov3" title="5">{
                s.enforceSecureConnection = enforceSecureConnection
        }</span>
}

// WithEnforceAuthentication enforces authentication before mail usage.
func WithEnforceAuthentication(enforceAuthentication bool) Option <span class="cov2" title="3">{
        return func(s *Server) </span><span class="cov2" title="3">{
                s.enforceAuthentication = enforceAuthentication
        }</span>
}

// WithReaderSize sets ReaderSize.
func WithReaderSize(readerSize int) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.readerSize = readerSize
        }</span>
}

// WithWriterSize sets WriterSize.
func WithWriterSize(writerSize int) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.writerSize = writerSize
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package tester

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "math/big"
        "time"
)

// GenX509KeyPair generates a self signed smtp server certificate with the given domain.
func GenX509KeyPair(domain string) (tls.Certificate, error) <span class="cov10" title="4">{
        now := time.Now()
        template := &amp;x509.Certificate{
                SerialNumber: big.NewInt(now.Unix()),
                Subject: pkix.Name{
                        CommonName:         domain,
                        Country:            []string{"Germany"},
                        Organization:       []string{"UPONU GmbH"},
                        OrganizationalUnit: []string{"mail:u secure"},
                },
                NotBefore:             now.AddDate(0, 0, -1),
                NotAfter:              now.AddDate(999, 0, 0),
                SubjectKeyId:          []byte{113, 117, 105, 99, 107, 115, 101, 114, 118, 101},
                BasicConstraintsValid: true,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                DNSNames:              []string{domain},
        }

        extSubjectAltName := pkix.Extension{}
        extSubjectAltName.Id = asn1.ObjectIdentifier{2, 5, 29, 17}
        extSubjectAltName.Critical = false

        var err error
        extSubjectAltName.Value, err = asn1.Marshal([]string{`dns:` + domain})
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        <span class="cov10" title="4">template.ExtraExtensions = []pkix.Extension{extSubjectAltName}

        priv, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        <span class="cov10" title="4">cert, err := x509.CreateCertificate(rand.Reader, template, template,
                priv.Public(), priv)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        <span class="cov10" title="4">var outCert tls.Certificate
        outCert.Certificate = append(outCert.Certificate, cert)
        outCert.PrivateKey = priv

        return outCert, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package tester

import (
        "bytes"
        "embed"
        "io"
        "path/filepath"
        "testing"

        "github.com/stretchr/testify/require"
)

func getAllFilenames(fs *embed.FS, path string) (out []string, err error) <span class="cov1" title="2">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                path = "."
        }</span>
        <span class="cov1" title="2">entries, err := fs.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="2">for _, entry := range entries </span><span class="cov1" title="3">{
                fp := filepath.Join(path, entry.Name())
                if entry.IsDir() </span><span class="cov0" title="0">{
                        res, err := getAllFilenames(fs, fp)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">out = append(out, res...)
                        continue</span>
                }
                <span class="cov1" title="3">out = append(out, fp)</span>
        }
        <span class="cov1" title="2">return out, err</span>
}

func chunkSlice(slice []byte, chunkSize int) [][]byte <span class="cov6" title="12141">{
        var chunks [][]byte
        for len(slice) != 0 </span><span class="cov10" title="1833129">{
                // necessary check to avoid slicing beyond
                // slice capacity
                if len(slice) &lt; chunkSize </span><span class="cov6" title="12121">{
                        chunkSize = len(slice)
                }</span>

                <span class="cov10" title="1833129">chunks = append(chunks, slice[0:chunkSize])
                slice = slice[chunkSize:]</span>
        }

        <span class="cov6" title="12141">return chunks</span>
}

func checkExpectedBufferAgainsActual(t *testing.T, b []byte, expected func(io.Writer) io.WriteCloser, actual func(io.Writer) io.WriteCloser) <span class="cov1" title="2">{
        var buf bytes.Buffer
        var err error

        f := expected(&amp;buf)
        _, err = f.Write(b)
        require.NoError(t, err)
        require.NoError(t, f.Close())

        size := 1

        for size &lt; 4048 &amp;&amp; len(b) &gt;= size </span><span class="cov6" title="8094">{
                bsplitted := chunkSlice(b, size)

                var buf1 bytes.Buffer
                f := actual(&amp;buf1)

                for _, b := range bsplitted </span><span class="cov9" title="1221404">{
                        _, err = f.Write(b)
                        require.NoError(t, err)
                }</span>

                <span class="cov6" title="8094">require.NoError(t, f.Close())

                require.Equal(t, buf, buf1)

                size++</span>
        }
}

// WriterCompareTest reads all files out of fs[path] and compares the expected func against the actual func.
// To simulate differences of Write calls of different sizes it slices the files in increasing sizes up to 4048.
func WriterCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Writer) io.WriteCloser, actual func(io.Writer) io.WriteCloser) <span class="cov1" title="1">{
        files, err := getAllFilenames(fs, path)
        require.NoError(t, err)

        for _, file := range files </span><span class="cov1" title="2">{
                dat, err := fs.ReadFile(file)
                require.NoError(t, err)
                checkExpectedBufferAgainsActual(t, []byte(dat), expected, actual)
        }</span>
}

func checkRaderExpectedAgainsActual(t *testing.T, b []byte, expected func(io.Reader) ([]byte, error), actual func(io.Reader) ([]byte, error)) <span class="cov1" title="1">{
        pr, pw := io.Pipe()

        go func() </span><span class="cov1" title="1">{
                _, err := pw.Write(b)
                require.NoError(t, err)
                err = pw.Close()
                require.NoError(t, err)
        }</span>()
        <span class="cov1" title="1">buf, err := expected(pr)
        require.ErrorIs(t, io.ErrUnexpectedEOF, err)

        size := 1
        for size &lt; 4048 &amp;&amp; len(b) &gt;= size </span><span class="cov6" title="4047">{
                bsplitted := chunkSlice(b, size)

                pr, pw = io.Pipe()

                go func() </span><span class="cov6" title="4047">{
                        for _, b := range bsplitted </span><span class="cov9" title="611725">{
                                _, err = pw.Write(b)
                                require.NoError(t, err)
                        }</span>
                        <span class="cov6" title="4047">err = pw.Close()
                        require.NoError(t, err)</span>
                }()

                <span class="cov6" title="4047">buf1, err := actual(pr)
                require.ErrorIs(t, io.ErrUnexpectedEOF, err)
                // print(string(buf), string(buf1))
                require.Equal(t, buf, buf1)

                size++</span>
        }
}

// ReaderCompareTest reads all files out of fs[path] and compares the result of the expected func against the actual func.
// To simulate differences of Read calls with different sizes it slices the files in increasing sizes up to 4048.
func ReaderCompareTest(t *testing.T, fs *embed.FS, path string, expected func(io.Reader) ([]byte, error), actual func(io.Reader) ([]byte, error)) <span class="cov1" title="1">{
        files, err := getAllFilenames(fs, path)
        require.NoError(t, err)

        for _, file := range files </span><span class="cov1" title="1">{
                dat, err := fs.ReadFile(file)
                require.NoError(t, err)
                checkRaderExpectedAgainsActual(t, []byte(dat), expected, actual)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package tester

import (
        "bytes"
        "io"
        "net"
        "strings"
        "time"
)

// FakeConn fakes a conn for testing.
type FakeConn struct {
        io.ReadWriter
        RemoteAddrReturn net.Addr
}

// NewFakeConnStream creates a new FakeConn with a stream as a input.
func NewFakeConnStream(in io.Reader, out *bytes.Buffer) *FakeConn <span class="cov6" title="17">{
        rw := struct {
                io.Reader
                io.Writer
        }{
                Reader: in,
                Writer: out,
        }

        return &amp;FakeConn{
                ReadWriter: rw,
        }
}</span>

// NewFakeConn creates a new FakeConn with a string as a input.
func NewFakeConn(in string, out *bytes.Buffer) *FakeConn <span class="cov5" title="11">{
        rw := struct {
                io.Reader
                io.Writer
        }{
                Reader: strings.NewReader(in),
                Writer: out,
        }

        return &amp;FakeConn{
                ReadWriter: rw,
        }
}</span>

// Close always returns nil.
func (FakeConn) Close() error <span class="cov6" title="18">{ return nil }</span>

// LocalAddr always returns nil.
func (FakeConn) LocalAddr() net.Addr <span class="cov0" title="0">{ return nil }</span>

// RemoteAddr always returns RemoteAddrReturn.
func (f FakeConn) RemoteAddr() net.Addr <span class="cov0" title="0">{ return f.RemoteAddrReturn }</span>

// SetDeadline always returns nil and does nothing.
func (FakeConn) SetDeadline(time.Time) error <span class="cov10" title="162">{ return nil }</span>

// SetReadDeadline always returns nil and does nothing.
func (FakeConn) SetReadDeadline(time.Time) error <span class="cov0" title="0">{ return nil }</span>

// SetWriteDeadline always returns nil and does nothing.
func (FakeConn) SetWriteDeadline(time.Time) error <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package tester

import "strings"

// Mail is one mail received by SMTP server.
type Mail struct {
        From       string
        Recipients []string
        Data       []byte
}

// LookupKey call LookupKey for current mail.
func (m *Mail) LookupKey() string <span class="cov10" title="7">{
        return m.From + "+" + strings.Join(m.Recipients, "+")
}</span>

// LookupKey returns a key of the format:
//
//        m.From+m.Recipient_1+m.Recipient_2...
func LookupKey(f string, r []string) string <span class="cov7" title="4">{
        return f + "+" + strings.Join(r, "+")
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package smtptester implements a simple SMTP server for testing. All
// received mails are saved in a sync.Map with a key:
//
//        From+Recipient1+Recipient2
//
// Mails to the same sender and recipients will overwrite a previous
// received mail, when the recipients slice has the same order as
// in the mail received before.
package tester

import (
        "context"
        "crypto/tls"
        "io"
        "log/slog"
        "sync"
        "time"

        "github.com/uponusolutions/go-sasl"
        "github.com/uponusolutions/go-smtp"
        "github.com/uponusolutions/go-smtp/server"
)

// Standard returns a standard SMTP server listening on a random Port.
func Standard() *server.Server <span class="cov2" title="2">{
        return server.New(
                server.WithAddr(":0"),
                server.WithReadTimeout(10*time.Second),
                server.WithWriteTimeout(10*time.Second),
                server.WithMaxMessageBytes(1024*1024),
                server.WithMaxRecipients(100),
                server.WithBackend(NewBackend()),
        )
}</span>

// StandardWithAddress with address returns a standard SMTP server listenting on addr.
func StandardWithAddress(addr string) *server.Server <span class="cov0" title="0">{
        return server.New(
                server.WithAddr(addr),
                server.WithReadTimeout(10*time.Second),
                server.WithWriteTimeout(10*time.Second),
                server.WithMaxMessageBytes(1024*1024),
                server.WithMaxRecipients(100),
                server.WithBackend(NewBackend()),
        )
}</span>

///////////////////////////////////////////////////////////////////////////
// Backend
///////////////////////////////////////////////////////////////////////////

// Backend is the backend for out test server.
// It contains a sync.Map with all mails received.
type Backend struct {
        Mails sync.Map
}

// NewBackend returns a new Backend with an empty (not nil) Mails map.
func NewBackend() *Backend <span class="cov2" title="2">{
        return &amp;Backend{Mails: sync.Map{}}
}</span>

// NewSession returns a new Session.
func (b *Backend) NewSession(ctx context.Context, _ *server.Conn) (context.Context, server.Session, error) <span class="cov5" title="7">{
        return ctx, newSession(b), nil
}</span>

// GetBackend returns the concrete type *Backend from SMTP server.
func GetBackend(s *server.Server) *Backend <span class="cov3" title="3">{
        if s.Backend() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">b, ok := s.Backend().(*Backend)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">return b</span>
}

// Add adds mail to backends map.
func (b *Backend) Add(m *Mail) <span class="cov3" title="4">{
        b.Mails.Store(m.LookupKey(), m)
}</span>

// Load loads mail from 'from' to recipients 'recipients'. The ok
// result indicates whether value was found in the map.
func (b *Backend) Load(from string, recipients []string) (*Mail, bool) <span class="cov3" title="4">{
        i, ok := b.Mails.Load(LookupKey(from, recipients))
        if !ok </span><span class="cov0" title="0">{
                return nil, ok
        }</span>

        <span class="cov3" title="4">return i.(*Mail), ok</span> //nolint
}

///////////////////////////////////////////////////////////////////////////
// Session
///////////////////////////////////////////////////////////////////////////

// A Session is returned after successful login.
type Session struct {
        backend *Backend
        mail    *Mail
}

func newSession(b *Backend) *Session <span class="cov5" title="7">{
        return &amp;Session{
                backend: b,
                mail:    &amp;Mail{},
        }
}</span>

// Reset implements Reset interface.
func (s *Session) Reset(ctx context.Context, _ bool) (context.Context, error) <span class="cov3" title="3">{
        s.mail = &amp;Mail{}

        return ctx, nil
}</span>

// Close implements the Close interface.
func (s *Session) Close(_ context.Context, _ error) <span class="cov5" title="7">{
        s.mail = &amp;Mail{}
}</span>

// Logger implements the Logger interface.
func (Session) Logger(_ context.Context) *slog.Logger <span class="cov10" title="72">{
        return nil
}</span>

// Verify implements the Verify interface.
func (Session) Verify(_ context.Context, _ string, _ *smtp.VrfyOptions) error <span class="cov0" title="0">{
        return nil
}</span>

// Mail implements the Mail interface.
func (s *Session) Mail(_ context.Context, from string, _ *smtp.MailOptions) error <span class="cov3" title="3">{
        s.mail.From = from

        return nil
}</span>

// Rcpt implements the Rcpt interface.
func (s *Session) Rcpt(_ context.Context, to string, _ *smtp.RcptOptions) error <span class="cov4" title="5">{
        s.mail.Recipients = append(s.mail.Recipients, to)

        return nil
}</span>

// Data implements the Data interface.
func (s *Session) Data(_ context.Context, r func() io.Reader) (string, error) <span class="cov3" title="3">{
        var err error

        if s.mail.Data, err = io.ReadAll(r()); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="3">s.backend.Add(s.mail)

        return "", nil</span>
}

// AuthMechanisms implements the AuthMechanisms interface.
func (Session) AuthMechanisms(_ context.Context) []string <span class="cov5" title="7">{
        return nil
}</span>

// Auth implements the Auth interface.
func (Session) Auth(_ context.Context, _ string) (sasl.Server, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// STARTTLS implements the STARTTLS interface.
func (Session) STARTTLS(_ context.Context, config *tls.Config) (*tls.Config, error) <span class="cov0" title="0">{
        return config, nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package smtp

import (
        "net"
        "time"
)

// Timeout sets a timeout by deadline to the connection and relieves it when returning func is used.
func Timeout(conn net.Conn, duration time.Duration) func() <span class="cov10" title="111">{
        _ = conn.SetDeadline(time.Now().Add(duration))
        return func() </span><span class="cov10" title="111">{
                _ = conn.SetDeadline(time.Time{})
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
